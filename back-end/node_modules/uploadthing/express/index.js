import * as Effect from 'effect/Effect';
import { Router } from 'express';
import { ValidContentDispositions, ValidACLs, fetchEff, generateUploadThingURL, parseResponseJson, RetryError, exponentialBackoff, UploadThingError, signPayload, isObject, getTypeFromFileName, objectKeys, InvalidRouteConfigError, fileSizeToBytes, bytesToFileSize, FetchContext, getFullApiUrl, verifySignature, parseRequestJson, fillInputRouteConfig, getStatusCodeFromError } from '@uploadthing/shared';
import * as S from '@effect/schema/Schema';
import { createConsola, LogLevels } from 'consola/core';
import * as Logger from 'effect/Logger';
import * as EffectLogLevel from 'effect/LogLevel';
import { process, isDevelopment } from 'std-env';
import * as Context from 'effect/Context';
import * as Data from 'effect/Data';
import { isActionType, VALID_ACTION_TYPES, isUploadThingHook, VALID_UT_HOOKS, UTFiles } from 'uploadthing/internal/types';
export { UTFiles } from 'uploadthing/internal/types';

var version = "6.12.0";

function defaultErrorFormatter(error) {
    return {
        message: error.message
    };
}
function formatError(error, router) {
    const errorFormatter = router[Object.keys(router)[0]]?._def.errorFormatter ?? defaultErrorFormatter;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return errorFormatter(error);
}

const ContentDispositionSchema = S.Literal(...ValidContentDispositions);
S.Literal(...ValidACLs);
/**
 * =============================================================================
 * ======================== File Type Hierarchy ===============================
 * =============================================================================
 */ /**
 * Properties from the web File object, this is what the client sends when initiating an upload
 */ class FileUploadData extends S.Class("FileUploadData")({
    name: S.String,
    size: S.Number,
    type: S.String
}) {
}
/**
 * `.middleware()` can add a customId to the incoming file data
 */ class FileUploadDataWithCustomId extends FileUploadData.extend("FileUploadDataWithCustomId")({
    customId: S.NullOr(S.String)
}) {
}
/**
 * When files are uploaded, we get back a key and a URL for the file
 */ class UploadedFileData extends FileUploadDataWithCustomId.extend("UploadedFileData")({
    key: S.String,
    url: S.String
}) {
}
/**
 * =============================================================================
 * ======================== Server Response Schemas ============================
 * =============================================================================
 */ class PresignedBase extends S.Class("PresignedBaseSchema")({
    key: S.String,
    fileName: S.String,
    fileType: S.String,
    fileUrl: S.String,
    pollingJwt: S.String,
    pollingUrl: S.String,
    contentDisposition: ContentDispositionSchema,
    customId: S.NullOr(S.String)
}) {
}
class MPUResponse extends PresignedBase.extend("MPUResponseSchema")({
    urls: S.Array(S.String),
    uploadId: S.String,
    chunkSize: S.Number,
    chunkCount: S.Number
}) {
}
class PSPResponse extends PresignedBase.extend("PSPResponseSchema")({
    url: S.String,
    fields: S.Record(S.String, S.String)
}) {
}
const PresignedURLResponse = S.Array(S.Union(PSPResponse, MPUResponse));
class PollUploadResponse extends S.Class("PollUploadResponse")({
    status: S.String,
    fileData: S.optional(S.Struct({
        fileKey: S.NullOr(S.String),
        fileName: S.String,
        fileSize: S.Number,
        fileType: S.String,
        metadata: S.NullOr(S.String),
        customId: S.NullOr(S.String),
        callbackUrl: S.optional(S.String),
        callbackSlug: S.optional(S.String)
    }))
}) {
}
class FailureCallbackResponse extends S.Class("FailureCallbackResponse")({
    success: S.Boolean,
    message: S.optional(S.String)
}) {
}
class ServerCallbackPostResponse extends S.Class("ServerCallbackPostResponse")({
    status: S.String
}) {
}
/**
 * =============================================================================
 * ======================== Client Action Payloads ============================
 * =============================================================================
 */ class UploadActionPayload extends S.Class("UploadActionPayload")({
    files: S.Array(FileUploadData),
    input: S.Unknown
}) {
}
class FailureActionPayload extends S.Class("FailureActionPayload")({
    fileKey: S.String,
    uploadId: S.NullOr(S.String),
    storageProviderError: S.optional(S.String),
    fileName: S.String
}) {
}
class MultipartCompleteActionPayload extends S.Class("MultipartCompleteActionPayload")({
    fileKey: S.String,
    uploadId: S.String,
    etags: S.Array(S.Struct({
        tag: S.String,
        partNumber: S.Number
    }))
}) {
}

const isValidResponse = (response)=>{
    if (!response.ok) return false;
    if (response.status >= 400) return false;
    if (!response.headers.has("x-uploadthing-version")) return false;
    return true;
};
const conditionalDevServer = (fileKey, apiKey)=>{
    return Effect.gen(function*() {
        const file = yield* fetchEff(generateUploadThingURL(`/api/pollUpload/${fileKey}`)).pipe(Effect.andThen(parseResponseJson), Effect.andThen(S.decodeUnknown(PollUploadResponse)), Effect.andThen((res)=>res.status === "done" ? Effect.succeed(res.fileData) : Effect.fail(new RetryError())), Effect.retry({
            while: (err)=>err instanceof RetryError,
            schedule: exponentialBackoff()
        }), Effect.catchTag("RetryError", (e)=>Effect.die(e)));
        if (file === undefined) {
            yield* Effect.logError(`Failed to simulate callback for file ${fileKey}`);
            return yield* new UploadThingError({
                code: "UPLOAD_FAILED",
                message: "File took too long to upload"
            });
        }
        let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;
        if (!callbackUrl.startsWith("http")) callbackUrl = "http://" + callbackUrl;
        yield* Effect.logInfo(`SIMULATING FILE UPLOAD WEBHOOK CALLBACK`, callbackUrl);
        const payload = JSON.stringify({
            status: "uploaded",
            metadata: JSON.parse(file.metadata ?? "{}"),
            file: new UploadedFileData({
                url: `https://utfs.io/f/${encodeURIComponent(fileKey)}`,
                key: fileKey,
                name: file.fileName,
                size: file.fileSize,
                customId: file.customId,
                type: file.fileType
            })
        });
        const signature = yield* Effect.tryPromise({
            try: ()=>signPayload(payload, apiKey),
            catch: (e)=>new UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: "Failed to sign payload",
                    cause: e
                })
        });
        const callbackResponse = yield* fetchEff(callbackUrl, {
            method: "POST",
            body: payload,
            headers: {
                "Content-Type": "application/json",
                "uploadthing-hook": "callback",
                "x-uploadthing-signature": signature
            }
        }).pipe(Effect.catchTag("FetchError", ()=>Effect.succeed(new Response(null, {
                status: 500
            }))));
        if (isValidResponse(callbackResponse)) {
            yield* Effect.logInfo("Successfully simulated callback for file", fileKey);
        } else {
            yield* Effect.logError(`
Failed to simulate callback for file '${file.fileKey}'. Is your webhook configured correctly?
  - Make sure the URL '${callbackUrl}' is accessible without any authentication. You can verify this by running 'curl -X POST ${callbackUrl}' in your terminal
  - Still facing issues? Read https://docs.uploadthing.com/faq for common issues
`.trim());
        }
        return file;
    });
};

const colorize = (str, level)=>{
    // TODO: Maybe check is shell supports colors
    switch(level){
        case "error":
        case "fatal":
            return `\x1b[41m\x1b[30m${str}\x1b[0m`;
        case "warn":
            return `\x1b[43m\x1b[30m${str}\x1b[0m`;
        case "info":
        case "log":
            return `\x1b[44m\x1b[30m${str}\x1b[0m`;
        case "debug":
            return `\x1b[47m\x1b[30m${str}\x1b[0m`;
        case "trace":
            return `\x1b[47m\x1b[30m${str}\x1b[0m`;
        case "success":
            return `\x1b[42m\x1b[30m${str}\x1b[0m`;
        default:
            return str;
    }
};
const icons = {
    fatal: "⨯",
    error: "⨯",
    warn: "⚠️",
    info: "ℹ",
    log: "ℹ",
    debug: "⚙",
    trace: "→",
    success: "✓"
};
function formatStack(stack) {
    const cwd = "cwd" in process && typeof process.cwd === "function" ? process.cwd() : "__UnknownCWD__";
    return "  " + stack.split("\n").splice(1).map((l)=>l.trim().replace("file://", "").replace(cwd + "/", "")).join("\n  ");
}
function formatArgs(args) {
    const fmtArgs = args.map((arg)=>{
        if (isObject(arg) && typeof arg.stack === "string") {
            return arg.message + "\n" + formatStack(arg.stack);
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return arg;
    });
    return fmtArgs.map((arg)=>{
        if (typeof arg === "string") {
            return arg;
        }
        return JSON.stringify(arg, null, 4);
    });
}
const logger = createConsola({
    reporters: [
        {
            log: (logObj)=>{
                const { type, tag, date, args } = logObj;
                const icon = icons[type];
                const logPrefix = colorize(` ${icon} ${tag} ${date.toLocaleTimeString()} `, type);
                const lines = formatArgs(args).join(" ") // concat all arguments to one space-separated string (like console does)
                .split("\n") // split all the newlines (e.g. from logged JSON.stringified objects)
                .map((l)=>logPrefix + " " + l) // prepend the log prefix to each line
                .join("\n"); // join all the lines back together
                // eslint-disable-next-line no-console
                console.log(lines);
            }
        }
    ],
    defaults: {
        tag: "UPLOADTHING"
    }
});
const effectLoggerLevelToConsolaLevel = {
    All: "verbose",
    Fatal: "error",
    Error: "error",
    Info: "info",
    Debug: "debug",
    Trace: "trace",
    Warning: "warn",
    None: "silent"
};
const withMinimalLogLevel = (level = "info")=>{
    logger.level = LogLevels[level];
    return Logger.withMinimumLogLevel({
        silent: EffectLogLevel.None,
        error: EffectLogLevel.Error,
        warn: EffectLogLevel.Warning,
        info: EffectLogLevel.Info,
        debug: EffectLogLevel.Debug,
        trace: EffectLogLevel.Trace,
        verbose: EffectLogLevel.All
    }[level]);
};
const ConsolaLogger = Logger.replace(Logger.defaultLogger, Logger.make(({ logLevel, message })=>{
    // FIXME: Probably log other stuff than just message?
    logger[effectLoggerLevelToConsolaLevel[logLevel._tag]](message);
}));

const completeMultipartUpload = (presigned, etags)=>fetchEff(generateUploadThingURL("/api/completeMultipart"), {
        method: "POST",
        body: JSON.stringify({
            fileKey: presigned.key,
            uploadId: presigned.uploadId,
            etags
        }),
        headers: {
            "Content-Type": "application/json"
        }
    }).pipe(Effect.andThen(parseResponseJson), Effect.andThen(S.decodeUnknown(S.Struct({
        success: S.Boolean,
        message: S.optional(S.String)
    }))), Effect.withSpan("completeMultipartUpload", {
        attributes: {
            etags,
            presigned
        }
    }));
const abortMultipartUpload = (presigned)=>fetchEff(generateUploadThingURL("/api/failureCallback"), {
        method: "POST",
        body: JSON.stringify({
            fileKey: presigned.key,
            uploadId: presigned.uploadId
        }),
        headers: {
            "Content-Type": "application/json"
        }
    }).pipe(Effect.andThen(parseResponseJson), Effect.andThen(S.decodeUnknown(FailureCallbackResponse)), Effect.withSpan("abortMultipartUpload", {
        attributes: {
            presigned
        }
    }));

function getParseFn(parser) {
    if (typeof parser.parse === "function") {
        return parser.parse;
    }
    throw new Error("Invalid parser");
}

const getApiKey = (apiKey)=>{
    if (apiKey) return apiKey;
    if (process.env.UPLOADTHING_SECRET) return process.env.UPLOADTHING_SECRET;
    return undefined;
};

class FileSizeMismatch extends Data.Error {
    constructor(type, max, actual){
        const reason = `You uploaded a ${type} file that was ${bytesToFileSize(actual)}, but the limit for that type is ${max}`;
        super({
            reason
        });
        this._tag = "FileSizeMismatch";
        this.name = "FileSizeMismatchError";
    }
}
class FileCountMismatch extends Data.Error {
    constructor(type, boundtype, bound, actual){
        const reason = `You uploaded ${actual} file(s) of type '${type}', but the ${boundtype} for that type is ${bound}`;
        super({
            reason
        });
        this._tag = "FileCountMismatch";
        this.name = "FileCountMismatchError";
    }
}
// Verify that the uploaded files doesn't violate the route config,
// e.g. uploading more videos than allowed, or a file that is larger than allowed.
// This is double-checked on infra side, but we want to fail early to avoid network latency.
const assertFilesMeetConfig = (files, routeConfig)=>Effect.gen(function*() {
        const counts = {};
        for (const file of files){
            const type = yield* getTypeFromFileName(file.name, objectKeys(routeConfig));
            counts[type] = (counts[type] ?? 0) + 1;
            const sizeLimit = routeConfig[type]?.maxFileSize;
            if (!sizeLimit) {
                return yield* new InvalidRouteConfigError(type, "maxFileSize");
            }
            const sizeLimitBytes = yield* fileSizeToBytes(sizeLimit);
            if (file.size > sizeLimitBytes) {
                return yield* new FileSizeMismatch(type, sizeLimit, file.size);
            }
        }
        for(const _key in counts){
            const key = _key;
            const config = routeConfig[key];
            if (!config) return yield* new InvalidRouteConfigError(key);
            const count = counts[key];
            const min = config.minFileCount;
            const max = config.maxFileCount;
            if (min > max) {
                return yield* new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "Invalid config during file count - minFileCount > maxFileCount",
                    cause: `minFileCount must be less than maxFileCount for key ${key}. got: ${min} > ${max}`
                });
            }
            if (count < min) {
                return yield* new FileCountMismatch(key, "minimum", min, count);
            }
            if (count > max) {
                return yield* new FileCountMismatch(key, "maximum", max, count);
            }
        }
        return null;
    });
class RequestInput extends /** #__PURE__ */ Context.Tag("uploadthing/RequestInput")() {
}
const parseAndValidateRequest = (input, opts, adapter)=>Effect.gen(function*() {
        const req = yield* Effect.isEffect(input.req) ? input.req : Effect.succeed(input.req);
        // Get inputs from query and params
        const url = new URL(req.url);
        const headers = req.headers;
        const params = url.searchParams;
        const action = params.get("actionType");
        const slug = params.get("slug");
        const hook = headers.get("uploadthing-hook");
        const utFrontendPackage = headers.get("x-uploadthing-package") ?? "unknown";
        const clientVersion = headers.get("x-uploadthing-version");
        const apiKey = getApiKey(opts.config?.uploadthingSecret);
        if (clientVersion != null && clientVersion !== version) {
            yield* Effect.logError(`Client version mismatch. Server version: ${version}, Client version: ${clientVersion}`);
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                message: "Client version mismatch",
                cause: `Server version: ${version}, Client version: ${clientVersion}`
            });
        }
        if (!slug) {
            yield* Effect.logError("No slug provided in params:", params);
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                message: "No slug provided in params"
            });
        }
        if (slug && typeof slug !== "string") {
            const msg = `Expected slug to be of type 'string', got '${typeof slug}'`;
            yield* Effect.logError(msg);
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                message: "`slug` must be a string",
                cause: msg
            });
        }
        if (!apiKey) {
            const msg = `No secret provided, please set UPLOADTHING_SECRET in your env file or in the config`;
            yield* Effect.logError(msg);
            return yield* new UploadThingError({
                code: "MISSING_ENV",
                message: `No secret provided`,
                cause: msg
            });
        }
        if (!apiKey.startsWith("sk_")) {
            const msg = `Invalid secret provided, UPLOADTHING_SECRET must start with 'sk_'`;
            yield* Effect.logError(msg);
            return yield* new UploadThingError({
                code: "MISSING_ENV",
                message: "Invalid API key. API keys must start with 'sk_'.",
                cause: msg
            });
        }
        if (utFrontendPackage && typeof utFrontendPackage !== "string") {
            const msg = `Expected x-uploadthing-package to be of type 'string', got '${typeof utFrontendPackage}'`;
            yield* Effect.logError(msg);
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                message: "`x-uploadthing-package` must be a string. eg. '@uploadthing/react'",
                cause: msg
            });
        }
        const uploadable = opts.router[slug];
        if (!uploadable) {
            const msg = `No file route found for slug ${slug}`;
            yield* Effect.logError(msg);
            return yield* new UploadThingError({
                code: "NOT_FOUND",
                message: msg
            });
        }
        if (action && !isActionType(action)) {
            const msg = `Expected ${VALID_ACTION_TYPES.map((x)=>`"${x}"`).join(", ").replace(/,(?!.*,)/, " or")} but got "${action}"`;
            yield* Effect.logError("Invalid action type", msg);
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                cause: `Invalid action type ${action}`,
                message: msg
            });
        }
        if (hook && !isUploadThingHook(hook)) {
            const msg = `Expected ${VALID_UT_HOOKS.map((x)=>`"${x}"`).join(", ").replace(/,(?!.*,)/, " or")} but got "${hook}"`;
            yield* Effect.logError("Invalid uploadthing hook", msg);
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                cause: `Invalid uploadthing hook ${hook}`,
                message: msg
            });
        }
        if (!action && !hook || action && hook) {
            const msg = `Exactly one of 'actionType' or 'uploadthing-hook' must be provided`;
            yield* Effect.logError(msg);
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                message: msg
            });
        }
        yield* Effect.logDebug("✔︎ All request input is valid");
        // FIXME: This should probably provide the full context at once instead of
        // partially in the `runRequestHandlerAsync` and partially in here...
        // Ref: https://discord.com/channels/@me/1201977154577891369/1207441839972548669
        const contextValue = yield* FetchContext;
        contextValue.baseHeaders["x-uploadthing-api-key"] = apiKey;
        contextValue.baseHeaders["x-uploadthing-fe-package"] = utFrontendPackage;
        contextValue.baseHeaders["x-uploadthing-be-adapter"] = adapter;
        const { isDev = isDevelopment } = opts.config ?? {};
        if (isDev) yield* Effect.logInfo("UploadThing dev server is now running!");
        const base = {
            req,
            config: opts.config ?? {},
            middlewareArgs: input.middlewareArgs,
            isDev,
            apiKey,
            slug,
            uploadable,
            hook: null,
            action: null
        };
        return action ? {
            ...base,
            action: action
        } : {
            ...base,
            hook: hook
        };
    });

const resolveCallbackUrl = Effect.gen(function*() {
    const { config, req, isDev } = yield* RequestInput;
    let callbackUrl = new URL(req.url);
    if (config?.callbackUrl) {
        callbackUrl = yield* getFullApiUrl(config.callbackUrl);
    } else if (process.env.UPLOADTHING_URL) {
        callbackUrl = yield* getFullApiUrl(process.env.UPLOADTHING_URL);
    }
    if (isDev || !callbackUrl.host.includes("localhost")) {
        return callbackUrl;
    }
    // Production builds have to have a public URL so UT can send webhook
    // Parse the URL from the headers
    let parsedFromHeaders = req.headers.get("origin") ?? req.headers.get("referer") ?? req.headers.get("host") ?? req.headers.get("x-forwarded-host");
    if (parsedFromHeaders && !parsedFromHeaders.includes("http")) {
        parsedFromHeaders = (req.headers.get("x-forwarded-proto") ?? "https") + "://" + parsedFromHeaders;
    }
    if (!parsedFromHeaders || parsedFromHeaders.includes("localhost")) {
        // Didn't find a valid URL in the headers, log a warning and use the original url anyway
        Effect.logWarning("You are using a localhost callback url in production which is not supported.", "Read more and learn how to fix it here: https://docs.uploadthing.com/faq#my-callback-runs-in-development-but-not-in-production");
        return callbackUrl;
    }
    return yield* getFullApiUrl(parsedFromHeaders);
});

/**
 * Allows adapters to be fully async/await instead of providing services and running Effect programs
 */ const runRequestHandlerAsync = (handler, args, config)=>handler(args).pipe(withMinimalLogLevel(config?.logLevel), Effect.provide(ConsolaLogger), Effect.provideService(FetchContext, {
        fetch: config?.fetch ?? globalThis.fetch,
        baseHeaders: {
            "x-uploadthing-version": version,
            // These are filled in later in `parseAndValidateRequest`
            "x-uploadthing-api-key": undefined,
            "x-uploadthing-be-adapter": undefined,
            "x-uploadthing-fe-package": undefined
        }
    }), asHandlerOutput, Effect.runPromise);
const asHandlerOutput = (effect)=>Effect.catchAll(effect, (error)=>Effect.succeed({
            success: false,
            error
        }));
const handleRequest = RequestInput.pipe(Effect.andThen(({ action, hook })=>{
    if (hook === "callback") return handleCallbackRequest;
    switch(action){
        case "upload":
            return handleUploadAction;
        case "multipart-complete":
            return handleMultipartCompleteAction;
        case "failure":
            return handleMultipartFailureAction;
    }
}), Effect.map((output)=>({
        success: true,
        ...output
    })));
const buildRequestHandler = (opts, adapter)=>(input)=>handleRequest.pipe(Effect.provideServiceEffect(RequestInput, parseAndValidateRequest(input, opts, adapter)), Effect.catchTags({
            InvalidJsonError: (e)=>new UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: "An error occured while parsing input/output",
                    cause: e
                }),
            BadRequestError: (e)=>Effect.fail(new UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: e.getMessage(),
                    cause: e,
                    data: e.json
                })),
            FetchError: (e)=>new UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: typeof e.error === "string" ? e.error : e.message,
                    cause: e,
                    data: e.error
                }),
            ParseError: (e)=>new UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: "An error occured while parsing input/output",
                    cause: e
                })
        }), Effect.tapError((e)=>Effect.logError(e.message)));
const handleCallbackRequest = Effect.gen(function*() {
    const { req, uploadable, apiKey } = yield* RequestInput;
    const verified = yield* Effect.tryPromise({
        try: async ()=>verifySignature(await req.clone().text(), req.headers.get("x-uploadthing-signature"), apiKey),
        catch: ()=>new UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid signature"
            })
    });
    yield* Effect.logDebug("Signature verified:", verified);
    if (!verified) {
        yield* Effect.logError("Invalid signature");
        return yield* new UploadThingError({
            code: "BAD_REQUEST",
            message: "Invalid signature"
        });
    }
    const requestInput = yield* Effect.flatMap(parseRequestJson(req), S.decodeUnknown(S.Struct({
        status: S.String,
        file: UploadedFileData,
        metadata: S.Record(S.String, S.Unknown)
    })));
    yield* Effect.logDebug("Handling callback request with input:", requestInput);
    const serverData = yield* Effect.tryPromise({
        try: async ()=>uploadable.resolver({
                file: requestInput.file,
                metadata: requestInput.metadata
            }),
        catch: (error)=>new UploadThingError({
                code: "INTERNAL_SERVER_ERROR",
                message: "Failed to run onUploadComplete",
                cause: error
            })
    }).pipe(Effect.tapError((error)=>Effect.logError("Failed to run onUploadComplete. You probably shouldn't be throwing errors here.", error)));
    const payload = {
        fileKey: requestInput.file.key,
        callbackData: serverData ?? null
    };
    yield* Effect.logDebug("'onUploadComplete' callback finished. Sending response to UploadThing:", payload);
    yield* fetchEff(generateUploadThingURL("/api/serverCallback"), {
        method: "POST",
        body: JSON.stringify(payload),
        headers: {
            "Content-Type": "application/json"
        }
    }).pipe(Effect.andThen(parseResponseJson), Effect.andThen(S.decodeUnknown(ServerCallbackPostResponse)));
    return {
        body: null
    };
});
const runRouteMiddleware = (opts)=>Effect.gen(function*() {
        const { uploadable, middlewareArgs } = yield* RequestInput;
        const { files, input } = opts;
        yield* Effect.logDebug("Running middleware");
        const metadata = yield* Effect.tryPromise({
            try: async ()=>uploadable._def.middleware({
                    ...middlewareArgs,
                    input,
                    files
                }),
            catch: (error)=>error instanceof UploadThingError ? error : new UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: "Failed to run middleware",
                    cause: error
                })
        }).pipe(Effect.tapError((error)=>Effect.logError("An error occured in your middleware function", error)));
        if (metadata[UTFiles] && metadata[UTFiles].length !== files.length) {
            const msg = `Expected files override to have the same length as original files, got ${metadata[UTFiles].length} but expected ${files.length}`;
            yield* Effect.logError(msg);
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                message: "Files override must have the same length as files",
                cause: msg
            });
        }
        // Attach customIds from middleware to the files
        const filesWithCustomIds = yield* Effect.forEach(files, (file, idx)=>Effect.gen(function*() {
                const theirs = metadata[UTFiles]?.[idx];
                if (theirs && theirs.size !== file.size) {
                    yield* Effect.logWarning("File size mismatch. Reverting to original size");
                }
                return {
                    name: theirs?.name ?? file.name,
                    size: file.size,
                    customId: theirs?.customId
                };
            }));
        return {
            metadata,
            filesWithCustomIds
        };
    });
const handleUploadAction = Effect.gen(function*() {
    const opts = yield* RequestInput;
    const { files, input } = yield* Effect.flatMap(parseRequestJson(opts.req), S.decodeUnknown(UploadActionPayload));
    yield* Effect.logDebug("Handling upload request with input:", {
        files,
        input
    });
    // validate the input
    yield* Effect.logDebug("Parsing user input");
    const inputParser = opts.uploadable._def.inputParser;
    const parsedInput = yield* Effect.tryPromise({
        try: async ()=>getParseFn(inputParser)(input),
        catch: (error)=>new UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid input",
                cause: error
            })
    }).pipe(Effect.tapError((error)=>Effect.logError("An error occured trying to parse input", error)));
    yield* Effect.logDebug("Input parsed successfully", parsedInput);
    const { metadata, filesWithCustomIds } = yield* runRouteMiddleware({
        input: parsedInput,
        files
    });
    yield* Effect.logDebug("Parsing route config", opts.uploadable._def.routerConfig);
    const parsedConfig = yield* fillInputRouteConfig(opts.uploadable._def.routerConfig).pipe(Effect.catchTag("InvalidRouteConfig", (err)=>new UploadThingError({
            code: "BAD_REQUEST",
            message: "Invalid config",
            cause: err
        })));
    yield* Effect.logDebug("Route config parsed successfully", parsedConfig);
    yield* Effect.logDebug("Validating files meet the config requirements", files);
    yield* assertFilesMeetConfig(files, parsedConfig).pipe(Effect.catchAll((e)=>new UploadThingError({
            code: "BAD_REQUEST",
            message: `Invalid config: ${e._tag}`,
            cause: "reason" in e ? e.reason : e.message
        })));
    const callbackUrl = yield* resolveCallbackUrl.pipe(Effect.tapError((error)=>Effect.logError("Failed to resolve callback URL", error)), Effect.catchTag("InvalidURL", (err)=>new UploadThingError({
            code: "INTERNAL_SERVER_ERROR",
            message: err.message
        })));
    yield* Effect.logDebug("Retrieving presigned URLs from UploadThing. Callback URL is:", callbackUrl.href);
    const presignedUrls = yield* fetchEff(generateUploadThingURL("/api/prepareUpload"), {
        method: "POST",
        body: JSON.stringify({
            files: filesWithCustomIds,
            routeConfig: parsedConfig,
            metadata,
            callbackUrl: callbackUrl.origin + callbackUrl.pathname,
            callbackSlug: opts.slug
        }),
        headers: {
            "Content-Type": "application/json"
        }
    }).pipe(Effect.andThen(parseResponseJson), Effect.andThen(S.decodeUnknown(PresignedURLResponse)));
    yield* Effect.logDebug("UploadThing responded with:", presignedUrls);
    yield* Effect.logDebug("Sending presigned URLs to client");
    let promise = undefined;
    if (opts.isDev) {
        const fetchContext = yield* FetchContext;
        promise = Effect.forEach(presignedUrls, (file)=>conditionalDevServer(file.key, opts.apiKey), {
            concurrency: 10
        }).pipe(Effect.provide(ConsolaLogger), Effect.provideService(FetchContext, fetchContext), Effect.runPromise);
    }
    return {
        body: presignedUrls,
        cleanup: promise
    };
});
const handleMultipartCompleteAction = Effect.gen(function*() {
    const opts = yield* RequestInput;
    const requestInput = yield* Effect.flatMap(parseRequestJson(opts.req), S.decodeUnknown(MultipartCompleteActionPayload));
    yield* Effect.logDebug("Handling multipart-complete request with input:", requestInput);
    yield* Effect.logDebug("Notifying UploadThing that multipart upload is complete");
    const completionResponse = yield* completeMultipartUpload({
        key: requestInput.fileKey,
        uploadId: requestInput.uploadId
    }, requestInput.etags);
    yield* Effect.logDebug("UploadThing responded with:", completionResponse);
    return {
        body: null
    };
});
const handleMultipartFailureAction = Effect.gen(function*() {
    const { req, uploadable } = yield* RequestInput;
    const { fileKey, uploadId } = yield* Effect.flatMap(parseRequestJson(req), S.decodeUnknown(FailureActionPayload));
    yield* Effect.logDebug("Handling failure request with input:", {
        fileKey,
        uploadId
    });
    yield* Effect.logDebug("Notifying UploadThing that upload failed");
    const failureResponse = yield* abortMultipartUpload({
        key: fileKey,
        uploadId
    });
    yield* Effect.logDebug("UploadThing responded with:", failureResponse);
    yield* Effect.logDebug("Running 'onUploadError' callback");
    yield* Effect.try({
        try: ()=>{
            uploadable._def.onUploadError({
                error: new UploadThingError({
                    code: "UPLOAD_FAILED",
                    message: `Upload failed for ${fileKey}`
                }),
                fileKey
            });
        },
        catch: (error)=>new UploadThingError({
                code: "INTERNAL_SERVER_ERROR",
                message: "Failed to run onUploadError",
                cause: error
            })
    }).pipe(Effect.tapError((error)=>Effect.logError("Failed to run onUploadError. You probably shouldn't be throwing errors here.", error)));
    return {
        body: null
    };
});
const buildPermissionsInfoHandler = (opts)=>{
    return ()=>{
        const permissions = objectKeys(opts.router).map((slug)=>{
            const route = opts.router[slug];
            const config = Effect.runSync(fillInputRouteConfig(route._def.routerConfig));
            return {
                slug,
                config
            };
        });
        return permissions;
    };
};

function incompatibleNodeGuard() {
    if (typeof process === "undefined") return;
    let major;
    let minor;
    const maybeNodeVersion = process.versions?.node?.split(".");
    if (maybeNodeVersion) {
        [major, minor] = maybeNodeVersion.map((v)=>parseInt(v, 10));
    }
    const maybeNodePath = process.env?.NODE;
    if (!major && maybeNodePath) {
        const nodeVersion = /v(\d+)\.(\d+)\.(\d+)/.exec(maybeNodePath)?.[0];
        if (nodeVersion) {
            [major, minor] = nodeVersion.substring(1).split(".").map((v)=>parseInt(v, 10));
        }
    }
    if (!major || !minor) return;
    // Require ^18.13.0
    if (major > 18) return;
    if (major === 18 && minor >= 13) return;
    Effect.runSync(Effect.logError(`YOU ARE USING A LEGACY (${major}.${minor}) NODE VERSION WHICH ISN'T OFFICIALLY SUPPORTED. PLEASE UPGRADE TO NODE ^18.13.`));
    // Kill the process if it isn't going to work correctly anyway
    // If we've gotten this far we know we have a Node.js runtime so exit is defined. Override std-env type.
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
    process.exit?.(1);
}

class InvalidURL extends Data.Error {
    constructor(attemptedUrl, base){
        Effect.runSync(Effect.logError(`Failed to parse URL from request. '${attemptedUrl}' is not a valid URL with base '${base}'.`));
        super({
            reason: `Failed to parse URL from request. '${attemptedUrl}' is not a valid URL with base '${base}'.`
        });
        this._tag = "InvalidURL";
        this.name = "InvalidURLError";
    }
}
const parseURL = (req)=>{
    const headers = req.headers;
    let relativeUrl = req.url ?? "/";
    if ("baseUrl" in req && typeof req.baseUrl === "string") {
        relativeUrl = req.baseUrl + relativeUrl;
    }
    const proto = headers?.["x-forwarded-proto"] ?? "http";
    const host = headers?.["x-forwarded-host"] ?? headers?.host;
    if (typeof proto !== "string" || typeof host !== "string") {
        return Effect.try({
            try: ()=>new URL(relativeUrl, process.env.UPLOADTHING_URL),
            catch: ()=>new InvalidURL(relativeUrl, process.env.UPLOADTHING_URL)
        });
    }
    return Effect.try({
        try: ()=>new URL(`${proto}://${host}${relativeUrl}`),
        catch: ()=>new InvalidURL(`${proto}://${host}${relativeUrl}`)
    });
};
const getPostBody = (opts)=>Effect.async((resume)=>{
        const { req } = opts;
        const contentType = req.headers?.["content-type"];
        if ("body" in req) {
            if (contentType !== "application/json") {
                Effect.runSync(Effect.logError("Expected JSON content type, got:", contentType));
                return resume(Effect.fail(new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "INVALID_CONTENT_TYPE"
                })));
            }
            if (typeof req.body !== "object") {
                Effect.runSync(Effect.logError("Expected body to be of type 'object', got:", typeof req.body));
                return resume(Effect.fail(new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "INVALID_BODY"
                })));
            }
            Effect.runSync(Effect.logDebug("Body parsed successfully.", req.body));
            return resume(Effect.succeed(req.body));
        }
        let body = "";
        req.on("data", (data)=>body += data);
        req.on("end", ()=>{
            const parsedBody = Effect.try({
                try: ()=>JSON.parse(body),
                catch: (err)=>new UploadThingError({
                        code: "BAD_REQUEST",
                        message: "INVALID_JSON",
                        cause: err
                    })
            });
            return resume(parsedBody);
        });
    });
const toWebRequest = (req, body)=>{
    body ??= req.body;
    const bodyStr = typeof body === "string" ? body : JSON.stringify(body);
    const method = req.method ?? "GET";
    const allowsBody = [
        "POST",
        "PUT",
        "PATCH"
    ].includes(method);
    const headers = new Headers();
    for (const [key, value] of Object.entries(req.headers ?? [])){
        if (typeof value === "string") headers.set(key, value);
        if (Array.isArray(value)) headers.set(key, value.join(","));
    }
    return parseURL(req).pipe(Effect.catchTag("InvalidURL", (e)=>Effect.die(e)), Effect.andThen((url)=>new Request(url, {
            method,
            headers,
            ...allowsBody ? {
                body: bodyStr
            } : {}
        })));
};

function internalCreateBuilder(initDef = {}) {
    const _def = {
        // Default router config
        routerConfig: {
            image: {
                maxFileSize: "4MB"
            }
        },
        inputParser: {
            parse: ()=>undefined,
            _input: undefined,
            _output: undefined
        },
        middleware: ()=>({}),
        onUploadError: ()=>({}),
        errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,
        // Overload with properties passed in
        ...initDef
    };
    return {
        input (userParser) {
            return internalCreateBuilder({
                ..._def,
                inputParser: userParser
            });
        },
        middleware (userMiddleware) {
            return internalCreateBuilder({
                ..._def,
                middleware: userMiddleware
            });
        },
        onUploadComplete (userUploadComplete) {
            return {
                _def,
                resolver: userUploadComplete
            };
        },
        onUploadError (userOnUploadError) {
            return internalCreateBuilder({
                ..._def,
                onUploadError: userOnUploadError
            });
        }
    };
}
function createBuilder(opts) {
    return (input)=>{
        return internalCreateBuilder({
            routerConfig: input,
            ...opts
        });
    };
}

const createUploadthing = (opts)=>createBuilder(opts);
const createRouteHandler = (opts)=>{
    incompatibleNodeGuard();
    const requestHandler = buildRequestHandler(opts, "express");
    const getBuildPerms = buildPermissionsInfoHandler(opts);
    const router = Router();
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    router.post("/", async (req, res)=>{
        const response = await runRequestHandlerAsync(requestHandler, {
            req: getPostBody({
                req
            }).pipe(Effect.andThen((body)=>toWebRequest(req, body))),
            middlewareArgs: {
                req,
                res,
                event: undefined
            }
        }, opts.config);
        if (response.success === false) {
            res.status(getStatusCodeFromError(response.error));
            res.setHeader("x-uploadthing-version", version);
            res.send(JSON.stringify(formatError(response.error, opts.router)));
            return;
        }
        res.setHeader("x-uploadthing-version", version);
        res.send(JSON.stringify(response.body));
    });
    router.get("/", (_req, res)=>{
        res.status(200);
        res.setHeader("x-uploadthing-version", version);
        res.send(JSON.stringify(getBuildPerms()));
    });
    return router;
};
/**
 * @deprecated Use {@link createRouteHandler} instead
 */ const createUploadthingExpressHandler = createRouteHandler;

export { createRouteHandler, createUploadthing, createUploadthingExpressHandler };
