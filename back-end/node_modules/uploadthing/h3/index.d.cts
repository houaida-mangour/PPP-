import * as S from '@effect/schema/Schema';
import * as _uploadthing_shared from '@uploadthing/shared';
import { FileRouterInputKey, Json, UploadThingError } from '@uploadthing/shared';
import * as h3 from 'h3';
import { H3Event } from 'h3';
import * as __internal_types from '../internal/types.cjs';
import { FileRouter, RouteHandlerOptions } from '../internal/types.cjs';
export { FileRouter, UTFiles } from '../internal/types.cjs';

declare const PresignedBase_base: S.Class<PresignedBase, {
    key: S.$String;
    fileName: S.$String;
    fileType: S.Schema<FileRouterInputKey, FileRouterInputKey, never>;
    fileUrl: S.$String;
    pollingJwt: S.$String;
    pollingUrl: S.$String;
    contentDisposition: S.Literal<["inline", "attachment"]>;
    customId: S.NullOr<S.$String>;
}, {
    readonly customId: string | null;
    readonly key: string;
    readonly fileName: string;
    readonly fileUrl: string;
    readonly pollingJwt: string;
    readonly pollingUrl: string;
    readonly contentDisposition: "inline" | "attachment";
    readonly fileType: FileRouterInputKey;
}, {
    readonly customId: string | null;
    readonly key: string;
    readonly fileName: string;
    readonly fileUrl: string;
    readonly pollingJwt: string;
    readonly pollingUrl: string;
    readonly contentDisposition: "inline" | "attachment";
    readonly fileType: FileRouterInputKey;
}, never, {
    readonly customId: string | null;
    readonly key: string;
    readonly fileName: string;
    readonly fileUrl: string;
    readonly pollingJwt: string;
    readonly pollingUrl: string;
    readonly contentDisposition: "inline" | "attachment";
    readonly fileType: FileRouterInputKey;
}, {}, {}>;
/**
 * =============================================================================
 * ======================== Server Response Schemas ============================
 * =============================================================================
 */
declare class PresignedBase extends PresignedBase_base {
}
declare const MPUResponse_base: S.Class<MPUResponse, {
    key: S.$String;
    fileName: S.$String;
    fileType: S.Schema<FileRouterInputKey, FileRouterInputKey, never>;
    fileUrl: S.$String;
    pollingJwt: S.$String;
    pollingUrl: S.$String;
    contentDisposition: S.Literal<["inline", "attachment"]>;
    customId: S.NullOr<S.$String>;
} & {
    urls: S.$Array<S.$String>;
    uploadId: S.$String;
    chunkSize: S.$Number;
    chunkCount: S.$Number;
}, {
    readonly customId: string | null;
    readonly key: string;
    readonly fileName: string;
    readonly fileUrl: string;
    readonly pollingJwt: string;
    readonly pollingUrl: string;
    readonly contentDisposition: "inline" | "attachment";
    readonly fileType: FileRouterInputKey;
    readonly urls: readonly string[];
    readonly uploadId: string;
    readonly chunkSize: number;
    readonly chunkCount: number;
}, {
    readonly customId: string | null;
    readonly key: string;
    readonly fileName: string;
    readonly fileUrl: string;
    readonly pollingJwt: string;
    readonly pollingUrl: string;
    readonly contentDisposition: "inline" | "attachment";
    readonly fileType: FileRouterInputKey;
    readonly urls: readonly string[];
    readonly uploadId: string;
    readonly chunkSize: number;
    readonly chunkCount: number;
}, never, {
    readonly customId: string | null;
    readonly key: string;
    readonly fileName: string;
    readonly fileUrl: string;
    readonly pollingJwt: string;
    readonly pollingUrl: string;
    readonly contentDisposition: "inline" | "attachment";
    readonly fileType: FileRouterInputKey;
    readonly urls: readonly string[];
    readonly uploadId: string;
    readonly chunkSize: number;
    readonly chunkCount: number;
}, PresignedBase, {}>;
declare class MPUResponse extends MPUResponse_base {
}
declare const PSPResponse_base: S.Class<PSPResponse, {
    key: S.$String;
    fileName: S.$String;
    fileType: S.Schema<FileRouterInputKey, FileRouterInputKey, never>;
    fileUrl: S.$String;
    pollingJwt: S.$String;
    pollingUrl: S.$String;
    contentDisposition: S.Literal<["inline", "attachment"]>;
    customId: S.NullOr<S.$String>;
} & {
    url: S.$String;
    fields: S.$Record<S.$String, S.$String>;
}, {
    readonly customId: string | null;
    readonly key: string;
    readonly fileName: string;
    readonly fileUrl: string;
    readonly pollingJwt: string;
    readonly pollingUrl: string;
    readonly contentDisposition: "inline" | "attachment";
    readonly fileType: FileRouterInputKey;
    readonly url: string;
    readonly fields: {
        readonly [x: string]: string;
    };
}, {
    readonly customId: string | null;
    readonly key: string;
    readonly fileName: string;
    readonly fileUrl: string;
    readonly pollingJwt: string;
    readonly pollingUrl: string;
    readonly contentDisposition: "inline" | "attachment";
    readonly fileType: FileRouterInputKey;
    readonly url: string;
    readonly fields: {
        readonly [x: string]: string;
    };
}, never, {
    readonly customId: string | null;
    readonly key: string;
    readonly fileName: string;
    readonly fileUrl: string;
    readonly pollingJwt: string;
    readonly pollingUrl: string;
    readonly contentDisposition: "inline" | "attachment";
    readonly fileType: FileRouterInputKey;
    readonly url: string;
    readonly fields: {
        readonly [x: string]: string;
    };
}, PresignedBase, {}>;
declare class PSPResponse extends PSPResponse_base {
}

type CreateBuilderOptions<TErrorShape extends Json> = {
    errorFormatter: (err: UploadThingError) => TErrorShape;
};

type MiddlewareArgs = {
    req: undefined;
    res: undefined;
    event: H3Event;
};
declare const createUploadthing: <TErrorShape extends Json>(opts?: CreateBuilderOptions<TErrorShape>) => (input: _uploadthing_shared.FileRouterInputConfig) => __internal_types.UploadBuilder<{
    _input: "unsetMarker" & {
        __brand: "unsetMarker";
    };
    _metadata: "unsetMarker" & {
        __brand: "unsetMarker";
    };
    _middlewareArgs: MiddlewareArgs;
    _errorShape: TErrorShape;
    _errorFn: "unsetMarker" & {
        __brand: "unsetMarker";
    };
    _output: "unsetMarker" & {
        __brand: "unsetMarker";
    };
}>;
declare const createRouteHandler: <TRouter extends FileRouter>(opts: RouteHandlerOptions<TRouter>) => h3.EventHandler<h3.EventHandlerRequest, Promise<{
    slug: keyof TRouter;
    config: _uploadthing_shared.ExpandedRouteConfig;
}[] | __internal_types.inferErrorShape<TRouter> | readonly (PSPResponse | MPUResponse)[] | "OK">>;
/**
 * @deprecated Use {@link createRouteHandler} instead
 */
declare const createH3EventHandler: <TRouter extends FileRouter>(opts: RouteHandlerOptions<TRouter>) => h3.EventHandler<h3.EventHandlerRequest, Promise<{
    slug: keyof TRouter;
    config: _uploadthing_shared.ExpandedRouteConfig;
}[] | __internal_types.inferErrorShape<TRouter> | readonly (PSPResponse | MPUResponse)[] | "OK">>;

export { createH3EventHandler, createRouteHandler, createUploadthing };
