Object.defineProperty(exports, '__esModule', { value: true });

var shared = require('@uploadthing/shared');
var S = require('@effect/schema/Schema');
var Effect = require('effect/Effect');
var core = require('consola/core');
var Logger = require('effect/Logger');
var EffectLogLevel = require('effect/LogLevel');
var stdEnv = require('std-env');
var Context = require('effect/Context');
var Data = require('effect/Data');
var types = require('uploadthing/internal/types');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return n;
}

var S__namespace = /*#__PURE__*/_interopNamespace(S);
var Effect__namespace = /*#__PURE__*/_interopNamespace(Effect);
var Logger__namespace = /*#__PURE__*/_interopNamespace(Logger);
var EffectLogLevel__namespace = /*#__PURE__*/_interopNamespace(EffectLogLevel);
var Context__namespace = /*#__PURE__*/_interopNamespace(Context);
var Data__namespace = /*#__PURE__*/_interopNamespace(Data);

var version = "6.12.0";

function defaultErrorFormatter(error) {
    return {
        message: error.message
    };
}
function formatError(error, router) {
    const errorFormatter = router[Object.keys(router)[0]]?._def.errorFormatter ?? defaultErrorFormatter;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return errorFormatter(error);
}

const ContentDispositionSchema = S__namespace.Literal(...shared.ValidContentDispositions);
S__namespace.Literal(...shared.ValidACLs);
/**
 * =============================================================================
 * ======================== File Type Hierarchy ===============================
 * =============================================================================
 */ /**
 * Properties from the web File object, this is what the client sends when initiating an upload
 */ class FileUploadData extends S__namespace.Class("FileUploadData")({
    name: S__namespace.String,
    size: S__namespace.Number,
    type: S__namespace.String
}) {
}
/**
 * `.middleware()` can add a customId to the incoming file data
 */ class FileUploadDataWithCustomId extends FileUploadData.extend("FileUploadDataWithCustomId")({
    customId: S__namespace.NullOr(S__namespace.String)
}) {
}
/**
 * When files are uploaded, we get back a key and a URL for the file
 */ class UploadedFileData extends FileUploadDataWithCustomId.extend("UploadedFileData")({
    key: S__namespace.String,
    url: S__namespace.String
}) {
}
/**
 * =============================================================================
 * ======================== Server Response Schemas ============================
 * =============================================================================
 */ class PresignedBase extends S__namespace.Class("PresignedBaseSchema")({
    key: S__namespace.String,
    fileName: S__namespace.String,
    fileType: S__namespace.String,
    fileUrl: S__namespace.String,
    pollingJwt: S__namespace.String,
    pollingUrl: S__namespace.String,
    contentDisposition: ContentDispositionSchema,
    customId: S__namespace.NullOr(S__namespace.String)
}) {
}
class MPUResponse extends PresignedBase.extend("MPUResponseSchema")({
    urls: S__namespace.Array(S__namespace.String),
    uploadId: S__namespace.String,
    chunkSize: S__namespace.Number,
    chunkCount: S__namespace.Number
}) {
}
class PSPResponse extends PresignedBase.extend("PSPResponseSchema")({
    url: S__namespace.String,
    fields: S__namespace.Record(S__namespace.String, S__namespace.String)
}) {
}
const PresignedURLResponse = S__namespace.Array(S__namespace.Union(PSPResponse, MPUResponse));
class PollUploadResponse extends S__namespace.Class("PollUploadResponse")({
    status: S__namespace.String,
    fileData: S__namespace.optional(S__namespace.Struct({
        fileKey: S__namespace.NullOr(S__namespace.String),
        fileName: S__namespace.String,
        fileSize: S__namespace.Number,
        fileType: S__namespace.String,
        metadata: S__namespace.NullOr(S__namespace.String),
        customId: S__namespace.NullOr(S__namespace.String),
        callbackUrl: S__namespace.optional(S__namespace.String),
        callbackSlug: S__namespace.optional(S__namespace.String)
    }))
}) {
}
class FailureCallbackResponse extends S__namespace.Class("FailureCallbackResponse")({
    success: S__namespace.Boolean,
    message: S__namespace.optional(S__namespace.String)
}) {
}
class ServerCallbackPostResponse extends S__namespace.Class("ServerCallbackPostResponse")({
    status: S__namespace.String
}) {
}
/**
 * =============================================================================
 * ======================== Client Action Payloads ============================
 * =============================================================================
 */ class UploadActionPayload extends S__namespace.Class("UploadActionPayload")({
    files: S__namespace.Array(FileUploadData),
    input: S__namespace.Unknown
}) {
}
class FailureActionPayload extends S__namespace.Class("FailureActionPayload")({
    fileKey: S__namespace.String,
    uploadId: S__namespace.NullOr(S__namespace.String),
    storageProviderError: S__namespace.optional(S__namespace.String),
    fileName: S__namespace.String
}) {
}
class MultipartCompleteActionPayload extends S__namespace.Class("MultipartCompleteActionPayload")({
    fileKey: S__namespace.String,
    uploadId: S__namespace.String,
    etags: S__namespace.Array(S__namespace.Struct({
        tag: S__namespace.String,
        partNumber: S__namespace.Number
    }))
}) {
}

const isValidResponse = (response)=>{
    if (!response.ok) return false;
    if (response.status >= 400) return false;
    if (!response.headers.has("x-uploadthing-version")) return false;
    return true;
};
const conditionalDevServer = (fileKey, apiKey)=>{
    return Effect__namespace.gen(function*() {
        const file = yield* shared.fetchEff(shared.generateUploadThingURL(`/api/pollUpload/${fileKey}`)).pipe(Effect__namespace.andThen(shared.parseResponseJson), Effect__namespace.andThen(S__namespace.decodeUnknown(PollUploadResponse)), Effect__namespace.andThen((res)=>res.status === "done" ? Effect__namespace.succeed(res.fileData) : Effect__namespace.fail(new shared.RetryError())), Effect__namespace.retry({
            while: (err)=>err instanceof shared.RetryError,
            schedule: shared.exponentialBackoff()
        }), Effect__namespace.catchTag("RetryError", (e)=>Effect__namespace.die(e)));
        if (file === undefined) {
            yield* Effect__namespace.logError(`Failed to simulate callback for file ${fileKey}`);
            return yield* new shared.UploadThingError({
                code: "UPLOAD_FAILED",
                message: "File took too long to upload"
            });
        }
        let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;
        if (!callbackUrl.startsWith("http")) callbackUrl = "http://" + callbackUrl;
        yield* Effect__namespace.logInfo(`SIMULATING FILE UPLOAD WEBHOOK CALLBACK`, callbackUrl);
        const payload = JSON.stringify({
            status: "uploaded",
            metadata: JSON.parse(file.metadata ?? "{}"),
            file: new UploadedFileData({
                url: `https://utfs.io/f/${encodeURIComponent(fileKey)}`,
                key: fileKey,
                name: file.fileName,
                size: file.fileSize,
                customId: file.customId,
                type: file.fileType
            })
        });
        const signature = yield* Effect__namespace.tryPromise({
            try: ()=>shared.signPayload(payload, apiKey),
            catch: (e)=>new shared.UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: "Failed to sign payload",
                    cause: e
                })
        });
        const callbackResponse = yield* shared.fetchEff(callbackUrl, {
            method: "POST",
            body: payload,
            headers: {
                "Content-Type": "application/json",
                "uploadthing-hook": "callback",
                "x-uploadthing-signature": signature
            }
        }).pipe(Effect__namespace.catchTag("FetchError", ()=>Effect__namespace.succeed(new Response(null, {
                status: 500
            }))));
        if (isValidResponse(callbackResponse)) {
            yield* Effect__namespace.logInfo("Successfully simulated callback for file", fileKey);
        } else {
            yield* Effect__namespace.logError(`
Failed to simulate callback for file '${file.fileKey}'. Is your webhook configured correctly?
  - Make sure the URL '${callbackUrl}' is accessible without any authentication. You can verify this by running 'curl -X POST ${callbackUrl}' in your terminal
  - Still facing issues? Read https://docs.uploadthing.com/faq for common issues
`.trim());
        }
        return file;
    });
};

const colorize = (str, level)=>{
    // TODO: Maybe check is shell supports colors
    switch(level){
        case "error":
        case "fatal":
            return `\x1b[41m\x1b[30m${str}\x1b[0m`;
        case "warn":
            return `\x1b[43m\x1b[30m${str}\x1b[0m`;
        case "info":
        case "log":
            return `\x1b[44m\x1b[30m${str}\x1b[0m`;
        case "debug":
            return `\x1b[47m\x1b[30m${str}\x1b[0m`;
        case "trace":
            return `\x1b[47m\x1b[30m${str}\x1b[0m`;
        case "success":
            return `\x1b[42m\x1b[30m${str}\x1b[0m`;
        default:
            return str;
    }
};
const icons = {
    fatal: "⨯",
    error: "⨯",
    warn: "⚠️",
    info: "ℹ",
    log: "ℹ",
    debug: "⚙",
    trace: "→",
    success: "✓"
};
function formatStack(stack) {
    const cwd = "cwd" in stdEnv.process && typeof stdEnv.process.cwd === "function" ? stdEnv.process.cwd() : "__UnknownCWD__";
    return "  " + stack.split("\n").splice(1).map((l)=>l.trim().replace("file://", "").replace(cwd + "/", "")).join("\n  ");
}
function formatArgs(args) {
    const fmtArgs = args.map((arg)=>{
        if (shared.isObject(arg) && typeof arg.stack === "string") {
            return arg.message + "\n" + formatStack(arg.stack);
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return arg;
    });
    return fmtArgs.map((arg)=>{
        if (typeof arg === "string") {
            return arg;
        }
        return JSON.stringify(arg, null, 4);
    });
}
const logger = core.createConsola({
    reporters: [
        {
            log: (logObj)=>{
                const { type, tag, date, args } = logObj;
                const icon = icons[type];
                const logPrefix = colorize(` ${icon} ${tag} ${date.toLocaleTimeString()} `, type);
                const lines = formatArgs(args).join(" ") // concat all arguments to one space-separated string (like console does)
                .split("\n") // split all the newlines (e.g. from logged JSON.stringified objects)
                .map((l)=>logPrefix + " " + l) // prepend the log prefix to each line
                .join("\n"); // join all the lines back together
                // eslint-disable-next-line no-console
                console.log(lines);
            }
        }
    ],
    defaults: {
        tag: "UPLOADTHING"
    }
});
const effectLoggerLevelToConsolaLevel = {
    All: "verbose",
    Fatal: "error",
    Error: "error",
    Info: "info",
    Debug: "debug",
    Trace: "trace",
    Warning: "warn",
    None: "silent"
};
const withMinimalLogLevel = (level = "info")=>{
    logger.level = core.LogLevels[level];
    return Logger__namespace.withMinimumLogLevel({
        silent: EffectLogLevel__namespace.None,
        error: EffectLogLevel__namespace.Error,
        warn: EffectLogLevel__namespace.Warning,
        info: EffectLogLevel__namespace.Info,
        debug: EffectLogLevel__namespace.Debug,
        trace: EffectLogLevel__namespace.Trace,
        verbose: EffectLogLevel__namespace.All
    }[level]);
};
const ConsolaLogger = Logger__namespace.replace(Logger__namespace.defaultLogger, Logger__namespace.make(({ logLevel, message })=>{
    // FIXME: Probably log other stuff than just message?
    logger[effectLoggerLevelToConsolaLevel[logLevel._tag]](message);
}));

const completeMultipartUpload = (presigned, etags)=>shared.fetchEff(shared.generateUploadThingURL("/api/completeMultipart"), {
        method: "POST",
        body: JSON.stringify({
            fileKey: presigned.key,
            uploadId: presigned.uploadId,
            etags
        }),
        headers: {
            "Content-Type": "application/json"
        }
    }).pipe(Effect__namespace.andThen(shared.parseResponseJson), Effect__namespace.andThen(S__namespace.decodeUnknown(S__namespace.Struct({
        success: S__namespace.Boolean,
        message: S__namespace.optional(S__namespace.String)
    }))), Effect__namespace.withSpan("completeMultipartUpload", {
        attributes: {
            etags,
            presigned
        }
    }));
const abortMultipartUpload = (presigned)=>shared.fetchEff(shared.generateUploadThingURL("/api/failureCallback"), {
        method: "POST",
        body: JSON.stringify({
            fileKey: presigned.key,
            uploadId: presigned.uploadId
        }),
        headers: {
            "Content-Type": "application/json"
        }
    }).pipe(Effect__namespace.andThen(shared.parseResponseJson), Effect__namespace.andThen(S__namespace.decodeUnknown(FailureCallbackResponse)), Effect__namespace.withSpan("abortMultipartUpload", {
        attributes: {
            presigned
        }
    }));

function getParseFn(parser) {
    if (typeof parser.parse === "function") {
        return parser.parse;
    }
    throw new Error("Invalid parser");
}

const getApiKey = (apiKey)=>{
    if (apiKey) return apiKey;
    if (stdEnv.process.env.UPLOADTHING_SECRET) return stdEnv.process.env.UPLOADTHING_SECRET;
    return undefined;
};

class FileSizeMismatch extends Data__namespace.Error {
    constructor(type, max, actual){
        const reason = `You uploaded a ${type} file that was ${shared.bytesToFileSize(actual)}, but the limit for that type is ${max}`;
        super({
            reason
        });
        this._tag = "FileSizeMismatch";
        this.name = "FileSizeMismatchError";
    }
}
class FileCountMismatch extends Data__namespace.Error {
    constructor(type, boundtype, bound, actual){
        const reason = `You uploaded ${actual} file(s) of type '${type}', but the ${boundtype} for that type is ${bound}`;
        super({
            reason
        });
        this._tag = "FileCountMismatch";
        this.name = "FileCountMismatchError";
    }
}
// Verify that the uploaded files doesn't violate the route config,
// e.g. uploading more videos than allowed, or a file that is larger than allowed.
// This is double-checked on infra side, but we want to fail early to avoid network latency.
const assertFilesMeetConfig = (files, routeConfig)=>Effect__namespace.gen(function*() {
        const counts = {};
        for (const file of files){
            const type = yield* shared.getTypeFromFileName(file.name, shared.objectKeys(routeConfig));
            counts[type] = (counts[type] ?? 0) + 1;
            const sizeLimit = routeConfig[type]?.maxFileSize;
            if (!sizeLimit) {
                return yield* new shared.InvalidRouteConfigError(type, "maxFileSize");
            }
            const sizeLimitBytes = yield* shared.fileSizeToBytes(sizeLimit);
            if (file.size > sizeLimitBytes) {
                return yield* new FileSizeMismatch(type, sizeLimit, file.size);
            }
        }
        for(const _key in counts){
            const key = _key;
            const config = routeConfig[key];
            if (!config) return yield* new shared.InvalidRouteConfigError(key);
            const count = counts[key];
            const min = config.minFileCount;
            const max = config.maxFileCount;
            if (min > max) {
                return yield* new shared.UploadThingError({
                    code: "BAD_REQUEST",
                    message: "Invalid config during file count - minFileCount > maxFileCount",
                    cause: `minFileCount must be less than maxFileCount for key ${key}. got: ${min} > ${max}`
                });
            }
            if (count < min) {
                return yield* new FileCountMismatch(key, "minimum", min, count);
            }
            if (count > max) {
                return yield* new FileCountMismatch(key, "maximum", max, count);
            }
        }
        return null;
    });
class RequestInput extends /** #__PURE__ */ Context__namespace.Tag("uploadthing/RequestInput")() {
}
const parseAndValidateRequest = (input, opts, adapter)=>Effect__namespace.gen(function*() {
        const req = yield* Effect__namespace.isEffect(input.req) ? input.req : Effect__namespace.succeed(input.req);
        // Get inputs from query and params
        const url = new URL(req.url);
        const headers = req.headers;
        const params = url.searchParams;
        const action = params.get("actionType");
        const slug = params.get("slug");
        const hook = headers.get("uploadthing-hook");
        const utFrontendPackage = headers.get("x-uploadthing-package") ?? "unknown";
        const clientVersion = headers.get("x-uploadthing-version");
        const apiKey = getApiKey(opts.config?.uploadthingSecret);
        if (clientVersion != null && clientVersion !== version) {
            yield* Effect__namespace.logError(`Client version mismatch. Server version: ${version}, Client version: ${clientVersion}`);
            return yield* new shared.UploadThingError({
                code: "BAD_REQUEST",
                message: "Client version mismatch",
                cause: `Server version: ${version}, Client version: ${clientVersion}`
            });
        }
        if (!slug) {
            yield* Effect__namespace.logError("No slug provided in params:", params);
            return yield* new shared.UploadThingError({
                code: "BAD_REQUEST",
                message: "No slug provided in params"
            });
        }
        if (slug && typeof slug !== "string") {
            const msg = `Expected slug to be of type 'string', got '${typeof slug}'`;
            yield* Effect__namespace.logError(msg);
            return yield* new shared.UploadThingError({
                code: "BAD_REQUEST",
                message: "`slug` must be a string",
                cause: msg
            });
        }
        if (!apiKey) {
            const msg = `No secret provided, please set UPLOADTHING_SECRET in your env file or in the config`;
            yield* Effect__namespace.logError(msg);
            return yield* new shared.UploadThingError({
                code: "MISSING_ENV",
                message: `No secret provided`,
                cause: msg
            });
        }
        if (!apiKey.startsWith("sk_")) {
            const msg = `Invalid secret provided, UPLOADTHING_SECRET must start with 'sk_'`;
            yield* Effect__namespace.logError(msg);
            return yield* new shared.UploadThingError({
                code: "MISSING_ENV",
                message: "Invalid API key. API keys must start with 'sk_'.",
                cause: msg
            });
        }
        if (utFrontendPackage && typeof utFrontendPackage !== "string") {
            const msg = `Expected x-uploadthing-package to be of type 'string', got '${typeof utFrontendPackage}'`;
            yield* Effect__namespace.logError(msg);
            return yield* new shared.UploadThingError({
                code: "BAD_REQUEST",
                message: "`x-uploadthing-package` must be a string. eg. '@uploadthing/react'",
                cause: msg
            });
        }
        const uploadable = opts.router[slug];
        if (!uploadable) {
            const msg = `No file route found for slug ${slug}`;
            yield* Effect__namespace.logError(msg);
            return yield* new shared.UploadThingError({
                code: "NOT_FOUND",
                message: msg
            });
        }
        if (action && !types.isActionType(action)) {
            const msg = `Expected ${types.VALID_ACTION_TYPES.map((x)=>`"${x}"`).join(", ").replace(/,(?!.*,)/, " or")} but got "${action}"`;
            yield* Effect__namespace.logError("Invalid action type", msg);
            return yield* new shared.UploadThingError({
                code: "BAD_REQUEST",
                cause: `Invalid action type ${action}`,
                message: msg
            });
        }
        if (hook && !types.isUploadThingHook(hook)) {
            const msg = `Expected ${types.VALID_UT_HOOKS.map((x)=>`"${x}"`).join(", ").replace(/,(?!.*,)/, " or")} but got "${hook}"`;
            yield* Effect__namespace.logError("Invalid uploadthing hook", msg);
            return yield* new shared.UploadThingError({
                code: "BAD_REQUEST",
                cause: `Invalid uploadthing hook ${hook}`,
                message: msg
            });
        }
        if (!action && !hook || action && hook) {
            const msg = `Exactly one of 'actionType' or 'uploadthing-hook' must be provided`;
            yield* Effect__namespace.logError(msg);
            return yield* new shared.UploadThingError({
                code: "BAD_REQUEST",
                message: msg
            });
        }
        yield* Effect__namespace.logDebug("✔︎ All request input is valid");
        // FIXME: This should probably provide the full context at once instead of
        // partially in the `runRequestHandlerAsync` and partially in here...
        // Ref: https://discord.com/channels/@me/1201977154577891369/1207441839972548669
        const contextValue = yield* shared.FetchContext;
        contextValue.baseHeaders["x-uploadthing-api-key"] = apiKey;
        contextValue.baseHeaders["x-uploadthing-fe-package"] = utFrontendPackage;
        contextValue.baseHeaders["x-uploadthing-be-adapter"] = adapter;
        const { isDev = stdEnv.isDevelopment } = opts.config ?? {};
        if (isDev) yield* Effect__namespace.logInfo("UploadThing dev server is now running!");
        const base = {
            req,
            config: opts.config ?? {},
            middlewareArgs: input.middlewareArgs,
            isDev,
            apiKey,
            slug,
            uploadable,
            hook: null,
            action: null
        };
        return action ? {
            ...base,
            action: action
        } : {
            ...base,
            hook: hook
        };
    });

const resolveCallbackUrl = Effect__namespace.gen(function*() {
    const { config, req, isDev } = yield* RequestInput;
    let callbackUrl = new URL(req.url);
    if (config?.callbackUrl) {
        callbackUrl = yield* shared.getFullApiUrl(config.callbackUrl);
    } else if (stdEnv.process.env.UPLOADTHING_URL) {
        callbackUrl = yield* shared.getFullApiUrl(stdEnv.process.env.UPLOADTHING_URL);
    }
    if (isDev || !callbackUrl.host.includes("localhost")) {
        return callbackUrl;
    }
    // Production builds have to have a public URL so UT can send webhook
    // Parse the URL from the headers
    let parsedFromHeaders = req.headers.get("origin") ?? req.headers.get("referer") ?? req.headers.get("host") ?? req.headers.get("x-forwarded-host");
    if (parsedFromHeaders && !parsedFromHeaders.includes("http")) {
        parsedFromHeaders = (req.headers.get("x-forwarded-proto") ?? "https") + "://" + parsedFromHeaders;
    }
    if (!parsedFromHeaders || parsedFromHeaders.includes("localhost")) {
        // Didn't find a valid URL in the headers, log a warning and use the original url anyway
        Effect__namespace.logWarning("You are using a localhost callback url in production which is not supported.", "Read more and learn how to fix it here: https://docs.uploadthing.com/faq#my-callback-runs-in-development-but-not-in-production");
        return callbackUrl;
    }
    return yield* shared.getFullApiUrl(parsedFromHeaders);
});

/**
 * Allows adapters to be fully async/await instead of providing services and running Effect programs
 */ const runRequestHandlerAsync = (handler, args, config)=>handler(args).pipe(withMinimalLogLevel(config?.logLevel), Effect__namespace.provide(ConsolaLogger), Effect__namespace.provideService(shared.FetchContext, {
        fetch: config?.fetch ?? globalThis.fetch,
        baseHeaders: {
            "x-uploadthing-version": version,
            // These are filled in later in `parseAndValidateRequest`
            "x-uploadthing-api-key": undefined,
            "x-uploadthing-be-adapter": undefined,
            "x-uploadthing-fe-package": undefined
        }
    }), asHandlerOutput, Effect__namespace.runPromise);
const asHandlerOutput = (effect)=>Effect__namespace.catchAll(effect, (error)=>Effect__namespace.succeed({
            success: false,
            error
        }));
const handleRequest = RequestInput.pipe(Effect__namespace.andThen(({ action, hook })=>{
    if (hook === "callback") return handleCallbackRequest;
    switch(action){
        case "upload":
            return handleUploadAction;
        case "multipart-complete":
            return handleMultipartCompleteAction;
        case "failure":
            return handleMultipartFailureAction;
    }
}), Effect__namespace.map((output)=>({
        success: true,
        ...output
    })));
const buildRequestHandler = (opts, adapter)=>(input)=>handleRequest.pipe(Effect__namespace.provideServiceEffect(RequestInput, parseAndValidateRequest(input, opts, adapter)), Effect__namespace.catchTags({
            InvalidJsonError: (e)=>new shared.UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: "An error occured while parsing input/output",
                    cause: e
                }),
            BadRequestError: (e)=>Effect__namespace.fail(new shared.UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: e.getMessage(),
                    cause: e,
                    data: e.json
                })),
            FetchError: (e)=>new shared.UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: typeof e.error === "string" ? e.error : e.message,
                    cause: e,
                    data: e.error
                }),
            ParseError: (e)=>new shared.UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: "An error occured while parsing input/output",
                    cause: e
                })
        }), Effect__namespace.tapError((e)=>Effect__namespace.logError(e.message)));
const handleCallbackRequest = Effect__namespace.gen(function*() {
    const { req, uploadable, apiKey } = yield* RequestInput;
    const verified = yield* Effect__namespace.tryPromise({
        try: async ()=>shared.verifySignature(await req.clone().text(), req.headers.get("x-uploadthing-signature"), apiKey),
        catch: ()=>new shared.UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid signature"
            })
    });
    yield* Effect__namespace.logDebug("Signature verified:", verified);
    if (!verified) {
        yield* Effect__namespace.logError("Invalid signature");
        return yield* new shared.UploadThingError({
            code: "BAD_REQUEST",
            message: "Invalid signature"
        });
    }
    const requestInput = yield* Effect__namespace.flatMap(shared.parseRequestJson(req), S__namespace.decodeUnknown(S__namespace.Struct({
        status: S__namespace.String,
        file: UploadedFileData,
        metadata: S__namespace.Record(S__namespace.String, S__namespace.Unknown)
    })));
    yield* Effect__namespace.logDebug("Handling callback request with input:", requestInput);
    const serverData = yield* Effect__namespace.tryPromise({
        try: async ()=>uploadable.resolver({
                file: requestInput.file,
                metadata: requestInput.metadata
            }),
        catch: (error)=>new shared.UploadThingError({
                code: "INTERNAL_SERVER_ERROR",
                message: "Failed to run onUploadComplete",
                cause: error
            })
    }).pipe(Effect__namespace.tapError((error)=>Effect__namespace.logError("Failed to run onUploadComplete. You probably shouldn't be throwing errors here.", error)));
    const payload = {
        fileKey: requestInput.file.key,
        callbackData: serverData ?? null
    };
    yield* Effect__namespace.logDebug("'onUploadComplete' callback finished. Sending response to UploadThing:", payload);
    yield* shared.fetchEff(shared.generateUploadThingURL("/api/serverCallback"), {
        method: "POST",
        body: JSON.stringify(payload),
        headers: {
            "Content-Type": "application/json"
        }
    }).pipe(Effect__namespace.andThen(shared.parseResponseJson), Effect__namespace.andThen(S__namespace.decodeUnknown(ServerCallbackPostResponse)));
    return {
        body: null
    };
});
const runRouteMiddleware = (opts)=>Effect__namespace.gen(function*() {
        const { uploadable, middlewareArgs } = yield* RequestInput;
        const { files, input } = opts;
        yield* Effect__namespace.logDebug("Running middleware");
        const metadata = yield* Effect__namespace.tryPromise({
            try: async ()=>uploadable._def.middleware({
                    ...middlewareArgs,
                    input,
                    files
                }),
            catch: (error)=>error instanceof shared.UploadThingError ? error : new shared.UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: "Failed to run middleware",
                    cause: error
                })
        }).pipe(Effect__namespace.tapError((error)=>Effect__namespace.logError("An error occured in your middleware function", error)));
        if (metadata[types.UTFiles] && metadata[types.UTFiles].length !== files.length) {
            const msg = `Expected files override to have the same length as original files, got ${metadata[types.UTFiles].length} but expected ${files.length}`;
            yield* Effect__namespace.logError(msg);
            return yield* new shared.UploadThingError({
                code: "BAD_REQUEST",
                message: "Files override must have the same length as files",
                cause: msg
            });
        }
        // Attach customIds from middleware to the files
        const filesWithCustomIds = yield* Effect__namespace.forEach(files, (file, idx)=>Effect__namespace.gen(function*() {
                const theirs = metadata[types.UTFiles]?.[idx];
                if (theirs && theirs.size !== file.size) {
                    yield* Effect__namespace.logWarning("File size mismatch. Reverting to original size");
                }
                return {
                    name: theirs?.name ?? file.name,
                    size: file.size,
                    customId: theirs?.customId
                };
            }));
        return {
            metadata,
            filesWithCustomIds
        };
    });
const handleUploadAction = Effect__namespace.gen(function*() {
    const opts = yield* RequestInput;
    const { files, input } = yield* Effect__namespace.flatMap(shared.parseRequestJson(opts.req), S__namespace.decodeUnknown(UploadActionPayload));
    yield* Effect__namespace.logDebug("Handling upload request with input:", {
        files,
        input
    });
    // validate the input
    yield* Effect__namespace.logDebug("Parsing user input");
    const inputParser = opts.uploadable._def.inputParser;
    const parsedInput = yield* Effect__namespace.tryPromise({
        try: async ()=>getParseFn(inputParser)(input),
        catch: (error)=>new shared.UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid input",
                cause: error
            })
    }).pipe(Effect__namespace.tapError((error)=>Effect__namespace.logError("An error occured trying to parse input", error)));
    yield* Effect__namespace.logDebug("Input parsed successfully", parsedInput);
    const { metadata, filesWithCustomIds } = yield* runRouteMiddleware({
        input: parsedInput,
        files
    });
    yield* Effect__namespace.logDebug("Parsing route config", opts.uploadable._def.routerConfig);
    const parsedConfig = yield* shared.fillInputRouteConfig(opts.uploadable._def.routerConfig).pipe(Effect__namespace.catchTag("InvalidRouteConfig", (err)=>new shared.UploadThingError({
            code: "BAD_REQUEST",
            message: "Invalid config",
            cause: err
        })));
    yield* Effect__namespace.logDebug("Route config parsed successfully", parsedConfig);
    yield* Effect__namespace.logDebug("Validating files meet the config requirements", files);
    yield* assertFilesMeetConfig(files, parsedConfig).pipe(Effect__namespace.catchAll((e)=>new shared.UploadThingError({
            code: "BAD_REQUEST",
            message: `Invalid config: ${e._tag}`,
            cause: "reason" in e ? e.reason : e.message
        })));
    const callbackUrl = yield* resolveCallbackUrl.pipe(Effect__namespace.tapError((error)=>Effect__namespace.logError("Failed to resolve callback URL", error)), Effect__namespace.catchTag("InvalidURL", (err)=>new shared.UploadThingError({
            code: "INTERNAL_SERVER_ERROR",
            message: err.message
        })));
    yield* Effect__namespace.logDebug("Retrieving presigned URLs from UploadThing. Callback URL is:", callbackUrl.href);
    const presignedUrls = yield* shared.fetchEff(shared.generateUploadThingURL("/api/prepareUpload"), {
        method: "POST",
        body: JSON.stringify({
            files: filesWithCustomIds,
            routeConfig: parsedConfig,
            metadata,
            callbackUrl: callbackUrl.origin + callbackUrl.pathname,
            callbackSlug: opts.slug
        }),
        headers: {
            "Content-Type": "application/json"
        }
    }).pipe(Effect__namespace.andThen(shared.parseResponseJson), Effect__namespace.andThen(S__namespace.decodeUnknown(PresignedURLResponse)));
    yield* Effect__namespace.logDebug("UploadThing responded with:", presignedUrls);
    yield* Effect__namespace.logDebug("Sending presigned URLs to client");
    let promise = undefined;
    if (opts.isDev) {
        const fetchContext = yield* shared.FetchContext;
        promise = Effect__namespace.forEach(presignedUrls, (file)=>conditionalDevServer(file.key, opts.apiKey), {
            concurrency: 10
        }).pipe(Effect__namespace.provide(ConsolaLogger), Effect__namespace.provideService(shared.FetchContext, fetchContext), Effect__namespace.runPromise);
    }
    return {
        body: presignedUrls,
        cleanup: promise
    };
});
const handleMultipartCompleteAction = Effect__namespace.gen(function*() {
    const opts = yield* RequestInput;
    const requestInput = yield* Effect__namespace.flatMap(shared.parseRequestJson(opts.req), S__namespace.decodeUnknown(MultipartCompleteActionPayload));
    yield* Effect__namespace.logDebug("Handling multipart-complete request with input:", requestInput);
    yield* Effect__namespace.logDebug("Notifying UploadThing that multipart upload is complete");
    const completionResponse = yield* completeMultipartUpload({
        key: requestInput.fileKey,
        uploadId: requestInput.uploadId
    }, requestInput.etags);
    yield* Effect__namespace.logDebug("UploadThing responded with:", completionResponse);
    return {
        body: null
    };
});
const handleMultipartFailureAction = Effect__namespace.gen(function*() {
    const { req, uploadable } = yield* RequestInput;
    const { fileKey, uploadId } = yield* Effect__namespace.flatMap(shared.parseRequestJson(req), S__namespace.decodeUnknown(FailureActionPayload));
    yield* Effect__namespace.logDebug("Handling failure request with input:", {
        fileKey,
        uploadId
    });
    yield* Effect__namespace.logDebug("Notifying UploadThing that upload failed");
    const failureResponse = yield* abortMultipartUpload({
        key: fileKey,
        uploadId
    });
    yield* Effect__namespace.logDebug("UploadThing responded with:", failureResponse);
    yield* Effect__namespace.logDebug("Running 'onUploadError' callback");
    yield* Effect__namespace.try({
        try: ()=>{
            uploadable._def.onUploadError({
                error: new shared.UploadThingError({
                    code: "UPLOAD_FAILED",
                    message: `Upload failed for ${fileKey}`
                }),
                fileKey
            });
        },
        catch: (error)=>new shared.UploadThingError({
                code: "INTERNAL_SERVER_ERROR",
                message: "Failed to run onUploadError",
                cause: error
            })
    }).pipe(Effect__namespace.tapError((error)=>Effect__namespace.logError("Failed to run onUploadError. You probably shouldn't be throwing errors here.", error)));
    return {
        body: null
    };
});
const buildPermissionsInfoHandler = (opts)=>{
    return ()=>{
        const permissions = shared.objectKeys(opts.router).map((slug)=>{
            const route = opts.router[slug];
            const config = Effect__namespace.runSync(shared.fillInputRouteConfig(route._def.routerConfig));
            return {
                slug,
                config
            };
        });
        return permissions;
    };
};

function incompatibleNodeGuard() {
    if (typeof stdEnv.process === "undefined") return;
    let major;
    let minor;
    const maybeNodeVersion = stdEnv.process.versions?.node?.split(".");
    if (maybeNodeVersion) {
        [major, minor] = maybeNodeVersion.map((v)=>parseInt(v, 10));
    }
    const maybeNodePath = stdEnv.process.env?.NODE;
    if (!major && maybeNodePath) {
        const nodeVersion = /v(\d+)\.(\d+)\.(\d+)/.exec(maybeNodePath)?.[0];
        if (nodeVersion) {
            [major, minor] = nodeVersion.substring(1).split(".").map((v)=>parseInt(v, 10));
        }
    }
    if (!major || !minor) return;
    // Require ^18.13.0
    if (major > 18) return;
    if (major === 18 && minor >= 13) return;
    Effect__namespace.runSync(Effect__namespace.logError(`YOU ARE USING A LEGACY (${major}.${minor}) NODE VERSION WHICH ISN'T OFFICIALLY SUPPORTED. PLEASE UPGRADE TO NODE ^18.13.`));
    // Kill the process if it isn't going to work correctly anyway
    // If we've gotten this far we know we have a Node.js runtime so exit is defined. Override std-env type.
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
    stdEnv.process.exit?.(1);
}

class InvalidURL extends Data__namespace.Error {
    constructor(attemptedUrl, base){
        Effect__namespace.runSync(Effect__namespace.logError(`Failed to parse URL from request. '${attemptedUrl}' is not a valid URL with base '${base}'.`));
        super({
            reason: `Failed to parse URL from request. '${attemptedUrl}' is not a valid URL with base '${base}'.`
        });
        this._tag = "InvalidURL";
        this.name = "InvalidURLError";
    }
}
const parseURL = (req)=>{
    const headers = req.headers;
    let relativeUrl = req.url ?? "/";
    if ("baseUrl" in req && typeof req.baseUrl === "string") {
        relativeUrl = req.baseUrl + relativeUrl;
    }
    const proto = headers?.["x-forwarded-proto"] ?? "http";
    const host = headers?.["x-forwarded-host"] ?? headers?.host;
    if (typeof proto !== "string" || typeof host !== "string") {
        return Effect__namespace.try({
            try: ()=>new URL(relativeUrl, stdEnv.process.env.UPLOADTHING_URL),
            catch: ()=>new InvalidURL(relativeUrl, stdEnv.process.env.UPLOADTHING_URL)
        });
    }
    return Effect__namespace.try({
        try: ()=>new URL(`${proto}://${host}${relativeUrl}`),
        catch: ()=>new InvalidURL(`${proto}://${host}${relativeUrl}`)
    });
};
const toWebRequest = (req, body)=>{
    body ??= req.body;
    const bodyStr = typeof body === "string" ? body : JSON.stringify(body);
    const method = req.method ?? "GET";
    const allowsBody = [
        "POST",
        "PUT",
        "PATCH"
    ].includes(method);
    const headers = new Headers();
    for (const [key, value] of Object.entries(req.headers ?? [])){
        if (typeof value === "string") headers.set(key, value);
        if (Array.isArray(value)) headers.set(key, value.join(","));
    }
    return parseURL(req).pipe(Effect__namespace.catchTag("InvalidURL", (e)=>Effect__namespace.die(e)), Effect__namespace.andThen((url)=>new Request(url, {
            method,
            headers,
            ...allowsBody ? {
                body: bodyStr
            } : {}
        })));
};

function internalCreateBuilder(initDef = {}) {
    const _def = {
        // Default router config
        routerConfig: {
            image: {
                maxFileSize: "4MB"
            }
        },
        inputParser: {
            parse: ()=>undefined,
            _input: undefined,
            _output: undefined
        },
        middleware: ()=>({}),
        onUploadError: ()=>({}),
        errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,
        // Overload with properties passed in
        ...initDef
    };
    return {
        input (userParser) {
            return internalCreateBuilder({
                ..._def,
                inputParser: userParser
            });
        },
        middleware (userMiddleware) {
            return internalCreateBuilder({
                ..._def,
                middleware: userMiddleware
            });
        },
        onUploadComplete (userUploadComplete) {
            return {
                _def,
                resolver: userUploadComplete
            };
        },
        onUploadError (userOnUploadError) {
            return internalCreateBuilder({
                ..._def,
                onUploadError: userOnUploadError
            });
        }
    };
}
function createBuilder(opts) {
    return (input)=>{
        return internalCreateBuilder({
            routerConfig: input,
            ...opts
        });
    };
}

const createUploadthing = (opts)=>createBuilder(opts);
const createRouteHandler = (fastify, opts, done)=>{
    incompatibleNodeGuard();
    const requestHandler = buildRequestHandler(opts, "fastify");
    const getBuildPerms = buildPermissionsInfoHandler(opts);
    const POST = async (req, res)=>{
        const response = await runRequestHandlerAsync(requestHandler, {
            req: toWebRequest(req),
            middlewareArgs: {
                req,
                res,
                event: undefined
            }
        }, opts.config);
        if (response.success === false) {
            void res.status(shared.getStatusCodeFromError(response.error)).headers({
                "x-uploadthing-version": version
            }).send(formatError(response.error, opts.router));
            return;
        }
        void res.headers({
            "x-uploadthing-version": version
        }).send(response.body);
    };
    const GET = async (req, res)=>{
        void res.status(200).headers({
            "x-uploadthing-version": version
        }).send(getBuildPerms());
    };
    fastify.post("/api/uploadthing", POST).get("/api/uploadthing", GET);
    done();
};
/**
 * @deprecated Use {@link createRouteHandler} instead
 */ const fastifyUploadthingPlugin = createRouteHandler;

Object.defineProperty(exports, "UTFiles", {
  enumerable: true,
  get: function () { return types.UTFiles; }
});
exports.createRouteHandler = createRouteHandler;
exports.createUploadthing = createUploadthing;
exports.fastifyUploadthingPlugin = fastifyUploadthingPlugin;
