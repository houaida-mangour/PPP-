import * as __internal_types from '../internal/types.cjs';
import { FileRouter, RouteHandlerOptions } from '../internal/types.cjs';
export { FileRouter, UTFiles } from '../internal/types.cjs';
import * as _uploadthing_shared from '@uploadthing/shared';
import { Json, UploadThingError, FetchEsque, MaybeUrl, ContentDisposition, ACL, Either, SerializedUploadThingError, Time } from '@uploadthing/shared';
export { UploadThingError } from '@uploadthing/shared';
import { Blob as Blob$1 } from 'buffer';
import { UploadedFileData } from '../types/index.js';

type CreateBuilderOptions<TErrorShape extends Json> = {
    errorFormatter: (err: UploadThingError) => TErrorShape;
};

/**
 * All the public log levels users can set.
 */
type LogLevel = "error" | "warn" | "info" | "debug" | "trace";

interface UTApiOptions {
    /**
     * Provide a custom fetch function.
     * @default globalThis.fetch
     */
    fetch?: FetchEsque;
    /**
     * Provide a custom UploadThing API key.
     * @default process.env.UPLOADTHING_SECRET
     */
    apiKey?: string;
    /**
     * @default "info"
     */
    logLevel?: LogLevel;
    /**
     * Set the default key type for file operations. Allows you to set your preferred filter
     * for file keys or custom identifiers without needing to specify it on every call.
     * @default "fileKey"
     */
    defaultKeyType?: "fileKey" | "customId";
}
type UrlWithOverrides = {
    url: MaybeUrl;
    name?: string;
    customId?: string;
};
type BlobEsque = Blob$1 | Blob;
type FileEsque = BlobEsque & {
    name: string;
    customId?: string | null | undefined;
};
interface UploadFilesOptions {
    metadata?: Json;
    contentDisposition?: ContentDisposition;
    acl?: ACL;
}
type UploadFileResult = Either<UploadedFileData, SerializedUploadThingError>;
interface KeyTypeOptionsBase {
    /**
     * Whether the provided key is a fileKey or a custom identifier. fileKey is the
     * identifier you get from UploadThing after uploading a file, customId is a
     * custom identifier you provided when uploading a file.
     * @default fileKey
     */
    keyType?: "fileKey" | "customId";
}
interface DeleteFilesOptions extends KeyTypeOptionsBase {
}
interface GetFileUrlsOptions extends KeyTypeOptionsBase {
}
interface ListFilesOptions {
    limit?: number;
    offset?: number;
}
type KeyRename = {
    key: string;
    newName: string;
};
type CustomIdRename = {
    customId: string;
    newName: string;
};
type RenameFileUpdate = KeyRename | CustomIdRename;
interface GetSignedURLOptions extends KeyTypeOptionsBase {
    /**
     * How long the URL will be valid for.
     * - Must be positive and less than 7 days (604800 seconds).
     * - You must accept overrides on the UploadThing dashboard for this option to be accepted.
     * @default app default on UploadThing dashboard
     */
    expiresIn?: Time;
}
interface ACLUpdateOptions extends KeyTypeOptionsBase {
}

interface UTFilePropertyBag extends BlobPropertyBag {
    lastModified?: number | undefined;
    customId?: string | undefined;
}
/**
 * Extension of the Blob class that simplifies setting the `name` and `customId` properties,
 * similar to the built-in File class from Node > 20.
 */
declare class UTFile extends Blob {
    name: string;
    lastModified: number;
    customId: string | undefined;
    constructor(parts: BlobPart[], name: string, options?: UTFilePropertyBag);
}

declare class UTApi {
    private fetch;
    private defaultHeaders;
    private defaultKeyType;
    private logLevel;
    constructor(opts?: UTApiOptions);
    private requestUploadThing;
    private executeAsync;
    /**
     * Upload files to UploadThing storage.
     *
     * @example
     * await uploadFiles(new File(["foo"], "foo.txt"));
     *
     * @example
     * await uploadFiles([
     *   new File(["foo"], "foo.txt"),
     *   new File(["bar"], "bar.txt"),
     * ]);
     */
    uploadFiles(files: FileEsque, opts?: UploadFilesOptions): Promise<UploadFileResult>;
    uploadFiles(files: FileEsque[], opts?: UploadFilesOptions): Promise<UploadFileResult[]>;
    /**
     * @param {string} url The URL of the file to upload
     * @param {Json} metadata JSON-parseable metadata to attach to the uploaded file(s)
     *
     * @example
     * await uploadFileFromUrl("https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
     *
     * @example
     * await uploadFileFromUrl([
     *   "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg",
     *   "https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"
     * ])
     */
    uploadFilesFromUrl(urls: MaybeUrl | UrlWithOverrides, opts?: UploadFilesOptions): Promise<UploadFileResult>;
    uploadFilesFromUrl(urls: (MaybeUrl | UrlWithOverrides)[], opts?: UploadFilesOptions): Promise<UploadFileResult[]>;
    /**
     * Request to delete files from UploadThing storage.
     * @param {string | string[]} fileKeys
     *
     * @example
     * await deleteFiles("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
     *
     * @example
     * await deleteFiles(["2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg","1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"])
     *
     * @example
     * await deleteFiles("myCustomIdentifier", { keyType: "customId" })
     */
    deleteFiles: (keys: string[] | string, opts?: DeleteFilesOptions) => Promise<{
        readonly success: boolean;
        readonly deletedCount: number;
    }>;
    /**
     * Request file URLs from UploadThing storage.
     * @param {string | string[]} fileKeys
     *
     * @example
     * const data = await getFileUrls("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
     * console.log(data); // [{key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", url: "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg"}]
     *
     * @example
     * const data = await getFileUrls(["2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg","1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"])
     * console.log(data) // [{key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", url: "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg" },{key: "1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg", url: "https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"}]
     */
    getFileUrls: (keys: string[] | string, opts?: GetFileUrlsOptions) => Promise<{
        readonly data: readonly {
            readonly key: string;
            readonly url: string;
        }[];
    }>;
    /**
     * Request file list from UploadThing storage.
     * @param {object} opts
     * @param {number} opts.limit The maximum number of files to return
     * @param {number} opts.offset The number of files to skip
     *
     * @example
     * const data = await listFiles({ limit: 1 });
     * console.log(data); // { key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", id: "2e0fdb64-9957-4262-8e45-f372ba903ac8" }
     */
    listFiles: (opts?: ListFilesOptions) => Promise<{
        readonly files: readonly {
            readonly name: string;
            readonly key: string;
            readonly customId: string | null;
            readonly status: "Deletion Pending" | "Failed" | "Uploaded" | "Uploading";
            readonly id: string;
        }[];
        readonly hasMore: boolean;
    }>;
    renameFiles: (updates: RenameFileUpdate | RenameFileUpdate[]) => Promise<{
        readonly success: boolean;
    }>;
    /** @deprecated Use {@link renameFiles} instead. */
    renameFile: (updates: RenameFileUpdate | RenameFileUpdate[]) => Promise<{
        readonly success: boolean;
    }>;
    getUsageInfo: () => Promise<{
        readonly totalBytes: number;
        readonly appTotalBytes: number;
        readonly filesUploaded: number;
        readonly limitBytes: number;
    }>;
    /** Request a presigned url for a private file(s) */
    getSignedURL: (key: string, opts?: GetSignedURLOptions) => Promise<{
        readonly url: string;
    }>;
    /**
     * Update the ACL of a file or set of files.
     *
     * @example
     * // Make a single file public
     * await utapi.updateACL("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", "public-read");
     *
     * // Make multiple files private
     * await utapi.updateACL(
     *   [
     *     "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg",
     *     "1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg",
     *   ],
     *   "private",
     * );
     */
    updateACL: (keys: string | string[], acl: ACL, opts?: ACLUpdateOptions) => Promise<{
        readonly success: boolean;
    }>;
}

type MiddlewareArgs = {
    req: Request;
    res: undefined;
    event: undefined;
};
declare const createUploadthing: <TErrorShape extends Json>(opts?: CreateBuilderOptions<TErrorShape>) => (input: _uploadthing_shared.FileRouterInputConfig) => __internal_types.UploadBuilder<{
    _input: "unsetMarker" & {
        __brand: "unsetMarker";
    };
    _metadata: "unsetMarker" & {
        __brand: "unsetMarker";
    };
    _middlewareArgs: MiddlewareArgs;
    _errorShape: TErrorShape;
    _errorFn: "unsetMarker" & {
        __brand: "unsetMarker";
    };
    _output: "unsetMarker" & {
        __brand: "unsetMarker";
    };
}>;
interface ResponseWithCleanup extends Response {
    /** custom property where a Promise may be put that you can await in for example Cloudflare Workers */
    cleanup?: Promise<unknown>;
}
/** @internal */
declare const INTERNAL_DO_NOT_USE_createRouteHandlerCore: <TRouter extends FileRouter>(opts: RouteHandlerOptions<TRouter>, adapter: string) => {
    GET: (request: Request | {
        request: Request;
    }) => Response;
    POST: (request: Request | {
        request: Request;
    }) => Promise<Response | ResponseWithCleanup>;
};
declare const createRouteHandler: <TRouter extends FileRouter>(opts: RouteHandlerOptions<TRouter>) => {
    GET: (request: Request | {
        request: Request;
    }) => Response;
    POST: (request: Request | {
        request: Request;
    }) => Promise<Response | ResponseWithCleanup>;
};
declare const extractRouterConfig: (router: FileRouter) => {
    slug: string;
    config: _uploadthing_shared.ExpandedRouteConfig;
}[];
/**
 * @deprecated Use {@link createRouteHandler} instead
 */
declare const createServerHandler: <TRouter extends FileRouter>(opts: RouteHandlerOptions<TRouter>) => {
    GET: (request: Request | {
        request: Request;
    }) => Response;
    POST: (request: Request | {
        request: Request;
    }) => Promise<Response | ResponseWithCleanup>;
};

export { INTERNAL_DO_NOT_USE_createRouteHandlerCore, type ResponseWithCleanup, UTApi, UTFile, createRouteHandler, createServerHandler, createUploadthing, extractRouterConfig };
