import { MimeType } from '@uploadthing/mime-types';
import * as Effect from 'effect/Effect';
import * as Data from 'effect/Data';
import * as Context from 'effect/Context';
import * as Duration from 'effect/Duration';
import * as Schedule from 'effect/Schedule';
import { ReactNode, CSSProperties } from 'react';
import { JSX } from 'solid-js/jsx-runtime';
import { RenderFunction, StyleValue } from 'vue';

declare const ALLOWED_FILE_TYPES: readonly ["image", "video", "audio", "pdf", "text", "blob"];
type AllowedFileType = (typeof ALLOWED_FILE_TYPES)[number];

type JsonValue = string | number | boolean | null | undefined;
type JsonArray = JsonValue[];
type JsonObject = {
    [key: string]: JsonValue | JsonObject | JsonArray;
};
type Json = JsonValue | JsonObject | JsonArray;
type Overwrite<T, U> = Omit<T, keyof U> & U;
type WithRequired<T, K extends keyof T> = T & Required<Pick<T, K>>;
type ErrorMessage<TError extends string> = TError;
type Simplify<TType> = {
    [TKey in keyof TType]: TType[TKey];
} & {};
type MaybePromise<TType> = TType | Promise<TType>;
type Either<TData, TError> = {
    data: TData;
    error: null;
} | {
    data: null;
    error: TError;
};
type ExtendObjectIf<Predicate, ToAdd> = undefined extends Predicate ? {} : ToAdd;
type DeepPartial<T> = T extends object ? {
    [P in keyof T]?: DeepPartial<T[P]>;
} : T;
/**
 * A subset of the standard RequestInit properties needed by UploadThing internally.
 * @see RequestInit from lib.dom.d.ts
 */
interface RequestInitEsque {
    /**
     * Sets the request's body.
     */
    body?: FormData | ReadableStream | string | null;
    /**
     * Sets the request's associated headers.
     */
    headers?: [string, string][] | Record<string, string>;
    /**
     * The request's HTTP-style method.
     */
    method?: string;
}
/**
 * A subset of the standard Response properties needed by UploadThing internally.
 * @see Response from lib.dom.d.ts
 */
interface ResponseEsque {
    status: number;
    statusText: string;
    ok: boolean;
    /**
     * @remarks
     * The built-in Response::json() method returns Promise<any>, but
     * that's not as type-safe as unknown. We use unknown because we're
     * more type-safe. You do want more type safety, right? ðŸ˜‰
     */
    json: <T = unknown>() => Promise<T>;
    text: () => Promise<string>;
    blob: () => Promise<Blob>;
    headers: Headers;
    clone: () => ResponseEsque;
}
type MaybeUrl = string | URL;
/**
 * A subset of the standard fetch function type needed by UploadThing internally.
 * @see fetch from lib.dom.d.ts
 */
type FetchEsque = (input: RequestInfo | MaybeUrl, init?: RequestInit | RequestInitEsque) => Promise<ResponseEsque>;
type PowOf2 = 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256 | 512 | 1024;
type SizeUnit = "B" | "KB" | "MB" | "GB";
type FileSize = `${PowOf2}${SizeUnit}`;
type TimeShort = "s" | "m" | "h" | "d";
type TimeLong = "second" | "minute" | "hour" | "day";
type SuggestedNumbers = 2 | 3 | 4 | 5 | 6 | 7 | 10 | 15 | 30 | 60;
type AutoCompleteableNumber = SuggestedNumbers | (number & {});
type Time = number | `1${TimeShort}` | `${AutoCompleteableNumber}${TimeShort}` | `1 ${TimeLong}` | `${AutoCompleteableNumber} ${TimeLong}s`;
declare const ValidContentDispositions: readonly ["inline", "attachment"];
type ContentDisposition = (typeof ValidContentDispositions)[number];
declare const ValidACLs: readonly ["public-read", "private"];
type ACL = (typeof ValidACLs)[number];
type ImageProperties = {
    /** Specify the width of the image. */
    width?: number;
    /** Specify the height of the image. */
    height?: number;
    /**
     * Specify the aspect ratio of the image.
     * @remarks If both width and height are specified, this will be ignored.
     */
    aspectRatio?: number;
};
type AdditionalProperties<T> = Record<string, unknown> & T;
type RouteConfig<TAdditionalProperties extends Record<string, unknown>> = {
    /**
     * Human-readable file size limit
     * @example "1MB"
     * @default https://docs.uploadthing.com/api-reference/server#defaults
     */
    maxFileSize: FileSize;
    /**
     * Maximum number of files allowed to be uploaded of this type
     * @example 10
     * @default https://docs.uploadthing.com/api-reference/server#defaults
     */
    maxFileCount: number;
    /**
     * Minimum number of files allowed to be uploaded of this type
     * @remarks Must be <= maxFileCount
     * @example 2
     * @default 1
     */
    minFileCount: number;
    /**
     * Specify the [content disposition](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) of the uploaded file
     * @example "attachment"
     * @default "inline"
     */
    contentDisposition: ContentDisposition;
    /**
     * Specify the [access control list](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) of the uploaded file
     * @remarks This must be enabled for your app. See https://docs.uploadthing.com/regions-and-acl#access-controls.
     * @example "private"
     * @default "public-read"
     */
    acl?: ACL;
    /**
     * Additional properties to be passed to the client-side `useRouteConfig` hook
     * @remarks These properties are not validated on the server on upload
     */
    additionalProperties?: AdditionalProperties<TAdditionalProperties>;
};
type FileRouterInputKey = AllowedFileType | MimeType;
type ExpandedRouteConfig = {
    [key in FileRouterInputKey]?: key extends `image${string}` ? RouteConfig<ImageProperties> : RouteConfig<Record<string, unknown>>;
};
type EndpointMetadata = {
    slug: string;
    config: ExpandedRouteConfig;
}[];
type FileRouterInputConfig = FileRouterInputKey[] | DeepPartial<ExpandedRouteConfig>;

declare class InvalidRouteConfigError extends Data.Error<{
    reason: string;
}> {
    readonly _tag = "InvalidRouteConfig";
    readonly name = "InvalidRouteConfigError";
    constructor(type: string, field?: string);
}
declare class UnknownFileTypeError extends Data.Error<{
    reason: string;
}> {
    readonly _tag = "UnknownFileType";
    readonly name = "UnknownFileTypeError";
    constructor(fileName: string);
}
declare class InvalidFileTypeError extends Data.Error<{
    reason: string;
}> {
    readonly _tag = "InvalidFileType";
    readonly name = "InvalidFileTypeError";
    constructor(fileType: string, fileName: string);
}
declare class InvalidFileSizeError extends Data.Error<{
    reason: string;
}> {
    readonly _tag = "InvalidFileSize";
    readonly name = "InvalidFileSizeError";
    constructor(fileSize: string);
}
declare class InvalidURLError extends Data.Error<{
    reason: string;
}> {
    readonly _tag = "InvalidURL";
    readonly name = "InvalidURLError";
    constructor(attemptedUrl: string);
}
declare class RetryError extends Data.Error {
    readonly _tag = "RetryError";
    readonly name = "RetryError";
}
/**
 * @internal
 */
declare const getRequestUrl: (input: RequestInfo | URL) => string;
declare class FetchError extends Data.Error<{
    readonly input: {
        url: string;
        method: string | undefined;
        body: unknown;
        headers: Record<string, string>;
    };
    readonly error: unknown;
}> {
    readonly _tag = "FetchError";
    readonly name = "FetchError";
}
declare class InvalidJsonError extends Data.Error<{
    readonly input: unknown;
    readonly error: unknown;
}> {
    readonly _tag = "InvalidJsonError";
    readonly name = "InvalidJsonError";
}
declare class BadRequestError<T = unknown> extends Data.Error<{
    readonly message: string;
    readonly status: number;
    readonly json: T;
}> {
    readonly _tag = "BadRequestError";
    readonly name = "BadRequestError";
    getMessage(): string;
}

declare function isRouteArray(routeConfig: FileRouterInputConfig): routeConfig is FileRouterInputKey[];
declare function getDefaultSizeForType(fileType: FileRouterInputKey): FileSize;
/**
 * This function takes in the user's input and "upscales" it to a full config
 *
 * Example:
 * ```ts
 * ["image"] => { image: { maxFileSize: "4MB", limit: 1 } }
 * ```
 */
declare const fillInputRouteConfig: (routeConfig: FileRouterInputConfig) => Effect.Effect<ExpandedRouteConfig, InvalidRouteConfigError>;
declare const getTypeFromFileName: (fileName: string, allowedTypes: FileRouterInputKey[]) => Effect.Effect<FileRouterInputKey, UnknownFileTypeError | InvalidFileTypeError>;
declare function generateUploadThingURL(path: `/${string}`): string;
declare const FILESIZE_UNITS: readonly ["B", "KB", "MB", "GB"];
type FileSizeUnit = (typeof FILESIZE_UNITS)[number];
declare const fileSizeToBytes: (fileSize: FileSize) => Effect.Effect<number, InvalidFileSizeError>;
declare const bytesToFileSize: (bytes: number) => string;
declare function safeParseJSON<T>(input: string | ResponseEsque | Request): Promise<T | Error>;
/** typesafe Object.keys */
declare function objectKeys<T extends Record<string, unknown>>(obj: T): (keyof T)[];
/** checks if obj is a valid, non-null object */
declare function isObject(obj: unknown): obj is Record<string, unknown>;
declare function asArray<T>(val: T | T[]): T[];
/** construct content-disposition header */
declare function contentDisposition(contentDisposition: ContentDisposition, fileName: string): string;
declare function semverLite(required: string, toCheck: string): boolean;
declare const getFullApiUrl: (maybeUrl?: string) => Effect.Effect<URL, InvalidURLError>;
declare const resolveMaybeUrlArg: (maybeUrl: string | URL | undefined) => URL;

declare const ERROR_CODES: {
    readonly BAD_REQUEST: 400;
    readonly NOT_FOUND: 404;
    readonly FORBIDDEN: 403;
    readonly INTERNAL_SERVER_ERROR: 500;
    readonly INTERNAL_CLIENT_ERROR: 500;
    readonly TOO_LARGE: 413;
    readonly TOO_SMALL: 400;
    readonly TOO_MANY_FILES: 400;
    readonly KEY_TOO_LONG: 400;
    readonly URL_GENERATION_FAILED: 500;
    readonly UPLOAD_FAILED: 500;
    readonly MISSING_ENV: 500;
    readonly FILE_LIMIT_EXCEEDED: 500;
};
type ErrorCode = keyof typeof ERROR_CODES;
type UploadThingErrorOptions<T> = {
    code: keyof typeof ERROR_CODES;
    message?: string | undefined;
    cause?: unknown;
    data?: T;
};
interface SerializedUploadThingError {
    code: ErrorCode;
    message: string;
    data?: Json;
}
declare class UploadThingError<TShape extends Json = {
    message: string;
}> extends Data.Error<{
    message: string;
}> {
    readonly _tag = "UploadThingError";
    readonly name = "UploadThingError";
    readonly cause?: unknown;
    readonly code: ErrorCode;
    readonly data: TShape | undefined;
    constructor(initOpts: UploadThingErrorOptions<TShape> | string);
    static toObject(error: UploadThingError): SerializedUploadThingError;
    static serialize(error: UploadThingError): string;
}
declare function getErrorTypeFromStatusCode(statusCode: number): ErrorCode;
declare function getStatusCodeFromError(error: UploadThingError<any>): 400 | 404 | 403 | 500 | 413;
declare const INTERNAL_DO_NOT_USE__fatalClientError: (e: Error) => UploadThingError<{
    message: string;
}>;

type FetchContextService = {
    fetch: FetchEsque;
    baseHeaders: Record<string, string | undefined> & {
        "x-uploadthing-version": string;
        "x-uploadthing-api-key": string | undefined;
        "x-uploadthing-fe-package": string | undefined;
        "x-uploadthing-be-adapter": string | undefined;
    };
};
declare const FetchContext_base: Context.TagClass<FetchContext, "uploadthing/FetchContext", FetchContextService>;
declare class FetchContext extends /** #__PURE__ */ FetchContext_base {
}
interface ResponseWithURL extends ResponseEsque {
    requestUrl: string;
}
declare const fetchEff: (input: string | URL, init?: RequestInit) => Effect.Effect<ResponseWithURL, FetchError, FetchContext>;
declare const parseResponseJson: (res: ResponseWithURL) => Effect.Effect<unknown, InvalidJsonError | BadRequestError, never>;
declare const parseRequestJson: (req: Request) => Effect.Effect<unknown, InvalidJsonError, never>;
/**
 * Schedule that retries with exponential backoff, up to 1 minute.
 * 10ms * 4^n, where n is the number of retries.
 */
declare const exponentialBackoff: () => Schedule.Schedule<Duration.DurationInput, unknown, never>;

declare const generateMimeTypes: (typesOrRouteConfig: string[] | ExpandedRouteConfig) => string[];
declare const generateClientDropzoneAccept: (fileTypes: string[]) => {
    [k: string]: never[];
};
declare function getFilesFromClipboardEvent(event: ClipboardEvent): File[] | undefined;
/**
 * Shared helpers for our premade components that's reusable by multiple frameworks
 */
declare const generatePermittedFileTypes: (config?: ExpandedRouteConfig) => {
    fileTypes: FileRouterInputKey[];
    multiple: boolean;
};
declare const capitalizeStart: (str: string) => string;
declare const INTERNAL_doFormatting: (config?: ExpandedRouteConfig) => string;
declare const allowedContentTextLabelGenerator: (config?: ExpandedRouteConfig) => string;
type AnyRuntime = "react" | "solid" | "svelte" | "vue";
type MinCallbackArg = {
    __runtime: AnyRuntime;
};
type inferRuntime<T extends MinCallbackArg> = T["__runtime"] extends "react" ? "react" : T["__runtime"] extends "solid" ? "solid" : T["__runtime"] extends "svelte" ? "svelte" : T["__runtime"] extends "vue" ? "vue" : never;
type ElementEsque<TRuntime extends AnyRuntime> = TRuntime extends "react" ? ReactNode : TRuntime extends "solid" ? JSX.Element : ReturnType<RenderFunction>;
type CSSPropertiesEsque<TRuntime extends AnyRuntime> = TRuntime extends "react" ? CSSProperties : TRuntime extends "solid" ? JSX.CSSProperties : TRuntime extends "svelte" ? string : TRuntime extends "vue" ? StyleValue : never;
type StyleField<CallbackArg extends MinCallbackArg, TRuntime extends AnyRuntime = inferRuntime<CallbackArg>> = string | CSSPropertiesEsque<TRuntime> | ((arg: Omit<CallbackArg, "__runtime">) => string | CSSPropertiesEsque<TRuntime>);
type ContentField<CallbackArg extends MinCallbackArg, TRuntime extends AnyRuntime = inferRuntime<CallbackArg>> = ElementEsque<TRuntime> | ((arg: Omit<CallbackArg, "__runtime">) => ElementEsque<TRuntime>);
declare const styleFieldToClassName: <T extends MinCallbackArg>(styleField: StyleField<T> | undefined, args: T) => string;
declare const styleFieldToCssObject: <T extends MinCallbackArg>(styleField: StyleField<T> | undefined, args: T) => (CSSPropertiesEsque<inferRuntime<T>> & null) | {};
declare const contentFieldToContent: <T extends MinCallbackArg>(contentField: ContentField<T> | undefined, arg: T) => ElementEsque<inferRuntime<T>> | null | undefined;

declare const signPayload: (payload: string, secret: string) => Promise<string>;
declare const verifySignature: (payload: string, signature: string | null, secret: string) => Promise<boolean>;

export { type ACL, ALLOWED_FILE_TYPES, type AllowedFileType, BadRequestError, type ContentDisposition, type ContentField, type DeepPartial, type Either, type EndpointMetadata, type ErrorMessage, type ExpandedRouteConfig, type ExtendObjectIf, FILESIZE_UNITS, FetchContext, type FetchContextService, FetchError, type FetchEsque, type FileRouterInputConfig, type FileRouterInputKey, type FileSize, type FileSizeUnit, INTERNAL_DO_NOT_USE__fatalClientError, INTERNAL_doFormatting, InvalidFileSizeError, InvalidFileTypeError, InvalidJsonError, InvalidRouteConfigError, InvalidURLError, type Json, type JsonArray, type JsonObject, type JsonValue, type MaybePromise, type MaybeUrl, type Overwrite, type RequestInitEsque, type ResponseEsque, RetryError, type SerializedUploadThingError, type Simplify, type SizeUnit, type StyleField, type Time, type TimeLong, type TimeShort, UnknownFileTypeError, UploadThingError, ValidACLs, ValidContentDispositions, type WithRequired, allowedContentTextLabelGenerator, asArray, bytesToFileSize, capitalizeStart, contentDisposition, contentFieldToContent, exponentialBackoff, fetchEff, fileSizeToBytes, fillInputRouteConfig, generateClientDropzoneAccept, generateMimeTypes, generatePermittedFileTypes, generateUploadThingURL, getDefaultSizeForType, getErrorTypeFromStatusCode, getFilesFromClipboardEvent, getFullApiUrl, getRequestUrl, getStatusCodeFromError, getTypeFromFileName, isObject, isRouteArray, objectKeys, parseRequestJson, parseResponseJson, resolveMaybeUrlArg, safeParseJSON, semverLite, signPayload, styleFieldToClassName, styleFieldToCssObject, verifySignature };
