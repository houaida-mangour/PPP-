'use client';
import { jsx, jsxs } from 'react/jsx-runtime';
import React, { useRef, useReducer, useEffect, useState, useMemo } from 'react';
import { twMerge } from 'tailwind-merge';
import { safeParseJSON, resolveMaybeUrlArg, semverLite, UploadThingError, INTERNAL_DO_NOT_USE__fatalClientError, generatePermittedFileTypes, generateMimeTypes, styleFieldToClassName, styleFieldToCssObject, contentFieldToContent, allowedContentTextLabelGenerator, getFilesFromClipboardEvent } from '@uploadthing/shared';
import { genUploader, version } from 'uploadthing/client';

var peerDependencies = {
	next: "*",
	react: "^17.0.2 || ^18.0.0",
	uploadthing: "^6.10.0"
};

// Ripped from https://github.com/scottrippey/react-use-event-hook
const noop = ()=>void 0;
/**
 * Suppress the warning when using useLayoutEffect with SSR. (https://reactjs.org/link/uselayouteffect-ssr)
 * Make use of useInsertionEffect if available.
 */ const useInsertionEffect = typeof window !== "undefined" ? React.useInsertionEffect || React.useLayoutEffect : noop;
/**
 * Similar to useCallback, with a few subtle differences:
 * - The returned function is a stable reference, and will always be the same between renders
 * - No dependency lists required
 * - Properties or state accessed within the callback will always be "current"
 */ function useEvent(callback) {
    // Keep track of the latest callback:
    const latestRef = React.useRef(// eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    useEvent_shouldNotBeInvokedBeforeMount);
    useInsertionEffect(()=>{
        latestRef.current = callback;
    }, [
        callback
    ]);
    // Create a stable callback that always calls the latest callback:
    // using useRef instead of useCallback avoids creating and empty array on every render
    const stableRef = React.useRef();
    if (!stableRef.current) {
        stableRef.current = function() {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return, prefer-rest-params, @typescript-eslint/no-unsafe-argument
            return latestRef.current.apply(this, arguments);
        };
    }
    return stableRef.current;
}
/**
 * Render methods should be pure, especially when concurrency is used,
 * so we will throw this error if the callback is called while rendering.
 */ function useEvent_shouldNotBeInvokedBeforeMount() {
    throw new Error("INVALID_USEEVENT_INVOCATION: the callback from useEvent cannot be invoked before the component has mounted.");
}

// Ripped from https://usehooks-ts.com/react-hook/use-fetch
function useFetch(url, options) {
    const cache = useRef({});
    // Used to prevent state update if the component is unmounted
    const cancelRequest = useRef(false);
    const initialState = {
        error: undefined,
        data: undefined
    };
    // Keep state logic separated
    const fetchReducer = (state, action)=>{
        switch(action.type){
            case "loading":
                return {
                    ...initialState
                };
            case "fetched":
                return {
                    ...initialState,
                    data: action.payload
                };
            case "error":
                return {
                    ...initialState,
                    error: action.payload
                };
            default:
                return state;
        }
    };
    const [state, dispatch] = useReducer(fetchReducer, initialState);
    useEffect(()=>{
        // Do nothing if the url is not given
        if (!url) return;
        cancelRequest.current = false;
        const fetchData = async ()=>{
            dispatch({
                type: "loading"
            });
            // If a cache exists for this url, return it
            if (cache.current[url]) {
                dispatch({
                    type: "fetched",
                    payload: cache.current[url]
                });
                return;
            }
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    throw new Error(response.statusText);
                }
                const dataOrError = await safeParseJSON(response);
                if (dataOrError instanceof Error) {
                    throw dataOrError;
                }
                cache.current[url] = dataOrError;
                if (cancelRequest.current) return;
                dispatch({
                    type: "fetched",
                    payload: dataOrError
                });
            } catch (error) {
                if (cancelRequest.current) return;
                dispatch({
                    type: "error",
                    payload: error
                });
            }
        };
        void fetchData();
        // Use the cleanup function for avoiding a possibly...
        // ...state update after the component was unmounted
        return ()=>{
            cancelRequest.current = true;
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        url
    ]);
    return state;
}

const useRouteConfig = (url, endpoint)=>{
    const maybeServerData = globalThis.__UPLOADTHING;
    const { data } = useFetch(// Don't fetch if we already have the data
    maybeServerData ? undefined : url.href);
    return (maybeServerData ?? data)?.find((x)=>x.slug === endpoint)?.config;
};
const INTERNAL_uploadthingHookGen = (initOpts)=>{
    if (!semverLite(peerDependencies.uploadthing, version)) {
        console.error(`!!!WARNING::: @uploadthing/react requires "uploadthing@${peerDependencies.uploadthing}", but version "${version}" is installed`);
    }
    const uploadFiles = genUploader({
        url: initOpts.url,
        package: "@uploadthing/react"
    });
    const useUploadThing = (endpoint, opts)=>{
        const [isUploading, setUploading] = useState(false);
        const uploadProgress = useRef(0);
        const fileProgress = useRef(new Map());
        const startUpload = useEvent(async (...args)=>{
            const files = await opts?.onBeforeUploadBegin?.(args[0]) ?? args[0];
            const input = args[1];
            setUploading(true);
            opts?.onUploadProgress?.(0);
            try {
                const res = await uploadFiles(endpoint, {
                    headers: opts?.headers,
                    files,
                    skipPolling: opts?.skipPolling,
                    onUploadProgress: (progress)=>{
                        if (!opts?.onUploadProgress) return;
                        fileProgress.current.set(progress.file, progress.progress);
                        let sum = 0;
                        fileProgress.current.forEach((p)=>{
                            sum += p;
                        });
                        const averageProgress = Math.floor(sum / fileProgress.current.size / 10) * 10;
                        if (averageProgress !== uploadProgress.current) {
                            opts?.onUploadProgress?.(averageProgress);
                            uploadProgress.current = averageProgress;
                        }
                    },
                    onUploadBegin ({ file }) {
                        if (!opts?.onUploadBegin) return;
                        opts.onUploadBegin(file);
                    },
                    // @ts-expect-error - input may not be defined on the type
                    input
                });
                await opts?.onClientUploadComplete?.(res);
                return res;
            } catch (e) {
                let error;
                if (e instanceof UploadThingError) {
                    error = e;
                } else {
                    error = INTERNAL_DO_NOT_USE__fatalClientError(e);
                    console.error("Something went wrong. Please contact UploadThing and provide the following cause:", error.cause instanceof Error ? error.cause.toString() : error.cause);
                }
                await opts?.onUploadError?.(error);
            } finally{
                setUploading(false);
                fileProgress.current = new Map();
                uploadProgress.current = 0;
            }
        });
        const routeConfig = useRouteConfig(initOpts.url, endpoint);
        return {
            startUpload,
            isUploading,
            routeConfig,
            /**
       * @deprecated Use `routeConfig` instead
       */ permittedFileInfo: routeConfig ? {
                slug: endpoint,
                config: routeConfig
            } : undefined
        };
    };
    return useUploadThing;
};
const generateReactHelpers = (initOpts)=>{
    const url = resolveMaybeUrlArg(initOpts?.url);
    const getRouteConfig = (endpoint)=>{
        const maybeServerData = globalThis.__UPLOADTHING;
        const config = maybeServerData?.find((x)=>x.slug === endpoint)?.config;
        if (!config) {
            throw new Error(`No config found for endpoint "${endpoint.toString()}". Please make sure to use the NextSSRPlugin in your Next.js app.`);
        }
        return config;
    };
    return {
        useUploadThing: INTERNAL_uploadthingHookGen({
            url
        }),
        uploadFiles: genUploader({
            url,
            package: "@uploadthing/react"
        }),
        /**
     * Get the config for a given endpoint outside of React context.
     * @remarks Can only be used if the NextSSRPlugin is used in the app.
     */ getRouteConfig
    };
};

const usePaste = (callback)=>{
    const stableCallback = useEvent(callback);
    useEffect(()=>{
        window.addEventListener("paste", stableCallback);
        return ()=>{
            window.removeEventListener("paste", stableCallback);
        };
    }, [
        stableCallback
    ]);
};

function Spinner() {
    return /*#__PURE__*/ jsx("svg", {
        className: "z-10 block h-5 w-5 animate-spin align-middle text-white",
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 576 512",
        children: /*#__PURE__*/ jsx("path", {
            fill: "currentColor",
            d: "M256 32C256 14.33 270.3 0 288 0C429.4 0 544 114.6 544 256C544 302.6 531.5 346.4 509.7 384C500.9 399.3 481.3 404.6 465.1 395.7C450.7 386.9 445.5 367.3 454.3 351.1C470.6 323.8 480 291 480 255.1C480 149.1 394 63.1 288 63.1C270.3 63.1 256 49.67 256 31.1V32z"
        })
    });
}
const progressWidths = {
    0: "after:w-0",
    10: "after:w-[10%]",
    20: "after:w-[20%]",
    30: "after:w-[30%]",
    40: "after:w-[40%]",
    50: "after:w-[50%]",
    60: "after:w-[60%]",
    70: "after:w-[70%]",
    80: "after:w-[80%]",
    90: "after:w-[90%]",
    100: "after:w-[100%]"
};

/**
 * @remarks It is not recommended using this directly as it requires manually binding generics. Instead, use `createUploadButton`.
 * @example
 * <UploadButton<OurFileRouter, "someEndpoint">
 *   endpoint="someEndpoint"
 *   onUploadComplete={(res) => console.log(res)}
 *   onUploadError={(err) => console.log(err)}
 * />
 */ function UploadButton(props) {
    // Cast back to UploadthingComponentProps<TRouter> to get the correct type
    // since the ErrorMessage messes it up otherwise
    const $props = props;
    const { mode = "auto", appendOnPaste = false } = $props.config ?? {};
    const useUploadThing = INTERNAL_uploadthingHookGen({
        url: resolveMaybeUrlArg($props.url)
    });
    const fileInputRef = useRef(null);
    const labelRef = useRef(null);
    const [uploadProgress, setUploadProgress] = useState($props.__internal_upload_progress ?? 0);
    const [files, setFiles] = useState([]);
    const { startUpload, isUploading, routeConfig } = useUploadThing($props.endpoint, {
        headers: $props.headers,
        skipPolling: !$props?.onClientUploadComplete ? true : $props?.skipPolling,
        onClientUploadComplete: (res)=>{
            if (fileInputRef.current) {
                fileInputRef.current.value = "";
            }
            setFiles([]);
            void $props.onClientUploadComplete?.(res);
            setUploadProgress(0);
        },
        onUploadProgress: (p)=>{
            setUploadProgress(p);
            $props.onUploadProgress?.(p);
        },
        onUploadError: $props.onUploadError,
        onUploadBegin: $props.onUploadBegin,
        onBeforeUploadBegin: $props.onBeforeUploadBegin
    });
    const { fileTypes, multiple } = generatePermittedFileTypes(routeConfig);
    const fileRouteInput = "input" in $props ? $props.input : undefined;
    const inputProps = useMemo(()=>({
            type: "file",
            ref: fileInputRef,
            multiple,
            accept: generateMimeTypes(fileTypes).join(", "),
            onChange: (e)=>{
                if (!e.target.files) return;
                const selectedFiles = Array.from(e.target.files);
                if (mode === "manual") {
                    setFiles(selectedFiles);
                    return;
                }
                void startUpload(selectedFiles, fileRouteInput);
            },
            disabled: fileTypes.length === 0,
            tabIndex: fileTypes.length === 0 ? -1 : 0
        }), [
        fileRouteInput,
        fileTypes,
        mode,
        multiple,
        startUpload
    ]);
    if ($props.__internal_button_disabled) inputProps.disabled = true;
    const state = (()=>{
        if ($props.__internal_state) return $props.__internal_state;
        if (inputProps.disabled) return "readying";
        if (!inputProps.disabled && !isUploading) return "ready";
        return "uploading";
    })();
    usePaste((event)=>{
        if (!appendOnPaste) return;
        if (document.activeElement !== fileInputRef.current) return;
        const pastedFiles = getFilesFromClipboardEvent(event);
        if (!pastedFiles) return;
        let filesToUpload = pastedFiles;
        setFiles((prev)=>{
            filesToUpload = [
                ...prev,
                ...pastedFiles
            ];
            return filesToUpload;
        });
        if (mode === "auto") {
            const input = "input" in $props ? $props.input : undefined;
            void startUpload(files, input);
        }
    });
    const styleFieldArg = {
        ready: state !== "readying",
        isUploading: state === "uploading",
        uploadProgress,
        fileTypes
    };
    const renderButton = ()=>{
        const customContent = contentFieldToContent($props.content?.button, styleFieldArg);
        if (customContent) return customContent;
        if (state === "readying") return "Loading...";
        if (state !== "uploading") {
            if (mode === "manual" && files.length > 0) {
                return `Upload ${files.length} file${files.length === 1 ? "" : "s"}`;
            }
            return `Choose File${inputProps.multiple ? `(s)` : ``}`;
        }
        if (uploadProgress === 100) return /*#__PURE__*/ jsx(Spinner, {});
        return /*#__PURE__*/ jsxs("span", {
            className: "z-50",
            children: [
                uploadProgress,
                "%"
            ]
        });
    };
    const renderClearButton = ()=>/*#__PURE__*/ jsx("button", {
            onClick: ()=>{
                setFiles([]);
                if (fileInputRef.current) {
                    fileInputRef.current.value = "";
                }
            },
            className: twMerge("h-[1.25rem] cursor-pointer rounded border-none bg-transparent text-gray-500 transition-colors hover:bg-slate-200 hover:text-gray-600", styleFieldToClassName($props.appearance?.clearBtn, styleFieldArg)),
            style: styleFieldToCssObject($props.appearance?.clearBtn, styleFieldArg),
            "data-state": state,
            "data-ut-element": "clear-btn",
            children: contentFieldToContent($props.content?.clearBtn, styleFieldArg) ?? "Clear"
        });
    const renderAllowedContent = ()=>/*#__PURE__*/ jsx("div", {
            className: twMerge("h-[1.25rem]  text-xs leading-5 text-gray-600", styleFieldToClassName($props.appearance?.allowedContent, styleFieldArg)),
            style: styleFieldToCssObject($props.appearance?.allowedContent, styleFieldArg),
            "data-state": state,
            "data-ut-element": "allowed-content",
            children: contentFieldToContent($props.content?.allowedContent, styleFieldArg) ?? allowedContentTextLabelGenerator(routeConfig)
        });
    return /*#__PURE__*/ jsxs("div", {
        className: twMerge("flex flex-col items-center justify-center gap-1", $props.className, styleFieldToClassName($props.appearance?.container, styleFieldArg)),
        style: styleFieldToCssObject($props.appearance?.container, styleFieldArg),
        "data-state": state,
        children: [
            /*#__PURE__*/ jsxs("label", {
                className: twMerge("relative flex h-10 w-36 cursor-pointer items-center justify-center overflow-hidden rounded-md text-white after:transition-[width] after:duration-500 focus-within:ring-2 focus-within:ring-blue-600 focus-within:ring-offset-2", state === "readying" && "cursor-not-allowed bg-blue-400", state === "uploading" && `bg-blue-400 after:absolute after:left-0 after:h-full after:bg-blue-600 after:content-[''] ${progressWidths[uploadProgress]}`, state === "ready" && "bg-blue-600", styleFieldToClassName($props.appearance?.button, styleFieldArg)),
                style: styleFieldToCssObject($props.appearance?.button, styleFieldArg),
                "data-state": state,
                "data-ut-element": "button",
                ref: labelRef,
                onClick: (e)=>{
                    if (mode === "manual" && files.length > 0) {
                        e.preventDefault();
                        e.stopPropagation();
                        const input = "input" in $props ? $props.input : undefined;
                        void startUpload(files, input);
                    }
                },
                children: [
                    /*#__PURE__*/ jsx("input", {
                        ...inputProps,
                        className: "sr-only"
                    }),
                    renderButton()
                ]
            }),
            mode === "manual" && files.length > 0 ? renderClearButton() : renderAllowedContent()
        ]
    });
}

export { INTERNAL_uploadthingHookGen as I, Spinner as S, UploadButton as U, generateReactHelpers as g, progressWidths as p };
